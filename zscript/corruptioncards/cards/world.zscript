// Cards that effect the world in other ways

Class CCard_SurpriseCyberdemon : Card
{
	override void Init()
	{
	effectWorld = true;
	tier = 4;
	description = "Add a Cyberdemon somewhere in the level.";
	image = "CARD02";
	background = "CARB27";
	canStack = true;
	cardtag = TAG_WORLD;
	Addtag("addspecialmonster");
	}

	String boss;

	override bool Condition()
	{
		Switch(GameInfo.gametype)
		{
			Case GAME_Doom:
			boss = "Cyberdemon";
			break;

			Case GAME_Heretic:
			boss = "Minotaur";
			break;
		}

		if(!boss)
		{
			return false;
		}

		class<Actor> rep = Actor.GetReplacement(boss);

		if(!rep)
		{
			return false;
		}


		if(rep == boss)
		{
			//description = "Add a " .. GetDefaultByType(rep).GetTag() .. " somewhere in the level.";
			description = Stringtable.Localize("$" .. "CC_HINT_SURPRISECYBERDEMON1");
			description.Replace("#", GetDefaultByType(rep).GetTag());
		}
		else
		{
			description = Stringtable.Localize("$" .. "CC_HINT_SURPRISECYBERDEMON2");
			//description = "Add a Boss Monster somewhere in the level.";
		}

		return !CCards_Functions.HasMapSpecial(rep);
	}

	override void OnGameStart(Actor a)
	{
		class<Actor> rep = Actor.GetReplacement(boss);
		if(!CCards_Functions.HasMapSpecial(rep))
		{
			CCards_Safespawner.New(rep.GetClassName(), 1, "CCards_Actor_BigSpawnFire", 40, 110, 0, 5);
		}
	}
}

Class CCard_KeyGuard : Card
{
	Array<Actor> keys;
	
	override void Init()
	{
		effectWorld = true;
		tier = 3;
		description = "Keys are guarded by Archviles.";
		image = "CARD15";
		background = "CARB07";
		canStack = false;
		FindKeys();
		cardtag = TAG_WORLD;
		Addtag("startspawn");
	}
	
	bool FindKeys()
	{
		keys.Clear();
		
		ThinkerIterator ti = ThinkerIterator.Create("Thinker");
				
			Thinker t;
				
			while (t = Thinker(ti.Next()))
			{
				Inventory inv = Inventory(t);
				if(inv)
				{
					if(!inv.owner)
					{
						if(CCards_Functions.ActorIsKey(inv))
						{
							keys.Push(inv);
						}
					}
				}
			}
		
		return (keys.Size()>0);
	}

	override bool Condition()
	{
		class<Actor> rep = Actor.GetReplacement("Archvile");

		if(rep.GetClassName() == "Archvile" && GameInfo.gametype == GAME_Doom && !CCards_Functions.IsDoom1() && FindKeys() > 0)
		{
			return true;
		}
		
		return false;
	}
	
	override void OnGameStart(Actor a)
	{	
		if(FindKeys())
		{
			for(int i=0; i<keys.Size(); i++)
			{
				if(keys[i])
				{
					let s = CCards_Safespawner.New("Archvile", 1, "CCards_Actor_SpawnFire", 20, 56, 0, 5);
					s.speed = 1;
					s.SetSpawnLocation(keys[i]);
				}
			}
		}
	}
}

Class CCard_Earthquake : Card
{
	mixin WorldEvent;
	
	override void Init()
	{
	effectWorld = true;
	tier = 2;
	description = "An earthquake may occur.";
	image = "CARD25";
	background = "CARB11";
	canStack = true;
	cardtag = TAG_EVENT;
	Addtag("mutual");
	Addtag("weather");
	}
	
	Array<Actor> actors;
	
	bool finished;
	bool windingdown;
	int quaketime;
	
	CCards_Actor_Earthquake q;

	void GetActors()
	{
		actors.Clear();
		ThinkerIterator ti = ThinkerIterator.Create("Actor");
			
		Actor t;
			
		while (t = Actor(ti.Next()))
		{
			if(t.player && t.player.mo != t)
			{
				continue;
			}

			if(t.GetClassName() == "CommanderKeen" || t.GetClassName() == "BossBrain")
			{
				continue;
			}
			
			if(t.special == 0 && 
			!(Actor.GetReplacee(t.GetClass()) is "Key") && 
			!t.bMISSILE && !(t is "CCards_Actor_MonsterDisguise"))
			{
				if(!t.bSHOOTABLE && !(t is "Inventory"))
				{
					continue;
				}
			}
			else
			{
				continue;
			}
			
			actors.Push(t);
		}
	}

	override void OnGameStart(Actor a)
	{
		SetEventTotals();
		finished = false;
		windingdown = false;
		quaketime = 0;
	}
	
	override void OnTick(actor a)
	{
		if(finished) 
		{
			return;
		}

		if(EventTrigger() && quaketime == 0)
		{
			ThinkerIterator ti = ThinkerIterator.Create("CCards_Actor_Earthquake");
		
			CCards_Actor_Earthquake qf = CCards_Actor_Earthquake(ti.Next());

			if(qf)
			{
				return;
			}

			q = CCards_Actor_Earthquake(Actor.Spawn("CCards_Actor_Earthquake"));//GetActors();
			quaketime++;
		}
		
		if(quaketime>0)
		{
			if(windingdown)
			{
				quaketime--;
			}
			else
			{
				quaketime++;
			}
			
			if(quaketime%8==0)
			{
				GetActors();
				for(int i = 0; i<actors.Size(); i++)
				{
					if(!actors[i])
					{
						continue;
					}
					
					if(actors[i].pos.z - actors[i].floorz == 0)
					{
						int thrust = min(quaketime, 100);
						int zthrust = thrust;
						
						if(actors[i].bISMONSTER)
						{
							if(!actors[i].bDROPOFF)
							{
								actors[i].GiveInventory("CCards_Actor_NewDropoff", 1);
								actors[i].bDROPOFF = true;
							}
							
							if(random(0, 5)==0 && quaketime > 35*2)
							{
								actors[i].angle = random(0, 360);
								actors[i].A_DamageSelf(1, "CardQuake");
								zthrust = zthrust * 2;
							}
						}

						if(actors[i] is "Inventory")
						{
							thrust = thrust * 2;
							zthrust = zthrust * 2;
						}

						if(actors[i] is "PlayerPawn")
						{
							zthrust = 0;
						}
						
						// Just in case it got removed by the damage
						if(actors[i])
						{
						actors[i].A_ChangeVelocity(random(-thrust, thrust) * 0.07, random(-thrust, thrust) * 0.07, random(0, zthrust * 0.04), CVF_RELATIVE); 
						}
					}
				}
			}
			
			if(quaketime>35*8)
			{
				windingdown = true;
				q.SetStateLabel("Death");
			}
			
			if(quaketime == 1 && windingdown)
			{
				finished = true;
				GetActors();
				for(int i = 0; i<actors.Size(); i++)
				{
					if(!actors[i].bISMONSTER)
					{
						continue;
					}

					if(actors[i].CountInv("CCards_Actor_NewDropoff")>0)
					{
						actors[i].A_TakeInventory("CCards_Actor_NewDropoff", 1);
						actors[i].bDROPOFF = false;
					}
					
					actors[i].bJUSTHIT = false;
					actors[i].bJUSTATTACKED = false;
				}
			}
		}
	}
}

class CCards_Actor_NewDropoff : Inventory {}

class CCards_Actor_Earthquake : Actor
{
	Default
	{
	+NOINTERACTION;
	}
	
	int ramp;
	
	states
	{
		Spawn:
		TNT1 A 0;
		TNT1 A 0 A_StartSound("corruptioncards/quake", CHAN_VOICE, flags:CHANF_LOOP, attenuation: ATTN_NONE);
		Quake:
		TNT1 A 35
		{
			ramp++;
			A_Quake(ramp, 35, 0, 99999, "");
		}
		loop;
		Death:
		TNT1 A 0 
		{
		ramp = 9;
		}
		Dying:
		TNT1 A 35
		{
			ramp--;
			A_Quake(ramp, 35, 0, 99999, "");
			if(ramp == 0)
			{
			SetStateLabel("End");
			}
		}
		loop;
		End:
		TNT1 A 0; //A_Log("bye");
		stop;
	}
}

Class CCards_WeatherManager : Thinker
{
	bool started;
	bool showRaining;
	bool isRaining;
	
	bool hasRain[32];
	int raintimer;
	int rainindex;
	Array<CCards_Rain> rainEffects;
	String translation;
	
	bool CheckRain(CCards_Rain r)
	{
		if(isRaining && rainEffects[rainindex] == r)
		{
		return true;
		}
		
		return false;
	}
	
	static CCards_WeatherManager Create()
	{
		ThinkerIterator WeatherFinder = ThinkerIterator.Create("CCards_WeatherManager");
		
		CCards_WeatherManager w = CCards_WeatherManager(WeatherFinder.Next());

		if(w)
		{
			//Console.Printf("weather manager found!");
			return w;
		}
		else
		{
			//Console.Printf("can't find a weather manager, making a new one");
			w = new ("CCards_WeatherManager");
			return w;
		}
	}

	void StartRain()
	{
		for(int i = 0; i<players.Size(); i++)
		{
			if(players[i].mo)
			{
				hasRain[i] = true;
				SpawnRain(i);
			}
		}
	}
	
	void SpawnRain(int playerno)
	{
		for(int i=0; i<75; i++)
		{
			rainvol[playerno] = 0;
			CCards_RainDrop r = CCards_RainDrop(Actor.Spawn("CCards_RainDrop", players[playerno].mo.pos));
			r.playerno = playerno;
			r.target = players[playerno].mo;
			r.weather = self;
		}
		
		/*CCards_RainSound s = CCards_RainSound(Actor.Spawn("CCards_RainSound", players[playerno].mo.pos));
		s.playerno = playerno;
		s.target = players[playerno].mo;
		s.weather = self;*/
	}
	
	void NewRain(CCards_Rain r)
	{
		rainEffects.Push(r);
		
		if(!started)
		{
			StartRain();
			started = true;
		}
		rainindex = random(0, rainEffects.Size()-1);
		raintimer = random(35*30, 35*60);
	}
	
	static bool CheckValidSkySectors()
	{
		int outdoors = 0;
		int indoors = 0;
	
		for (int i=0; i<level.sectors.size(); i++) 
		{
			if(TexMan.GetName(level.sectors[i].GetTexture(1)) == "F_SKY1")
			{
				outdoors++;
			}
			else
			{
				indoors++;
			}
		}

		if(outdoors > indoors || outdoors < 10)
		{
			return false;
		}
		
		return true;
	}
	
	override void Tick()
	{
		RainSound();
		
		if(rainEffects.Size()==0)
		{
		return;
		}
		raintimer--;
		Actor a;
		
		if(raintimer == 35*3)
		{
			S_Sound("corruptioncards/thunder", CHAN_AUTO, attenuation: ATTN_NONE);
		}
		
		if(raintimer == 35)
		{
			showRaining = true;
			translation = rainEffects[rainindex].translation;
		}
		
		if(raintimer == 0)
		{
			isRaining = true;
		}
		
		if(raintimer < - rainEffects[rainindex].duration)
		{
			isRaining = false;
			rainindex = random(0, rainEffects.Size()-1);
			showRaining = false;
			ResetRainTimer();
		}
	}
	
	void ResetRainTimer()
	{
		raintimer = random(2, 5) * (35*30);
	}
	
	float rainvol[32];
	
	void SetRainVol(int playerno, float volume)
	{
		if(volume<0)
		{
		return;
		}
		if(rainvol[playerno] < volume)
		{
			rainvol[playerno] = volume;//max(1000.0, rainvol[playerno] = volume);
		}
	}
	
	void RainSound()
	{
		for(int i; i<7; i++)
		{
			if(playerInGame[i])
			{
				if((Level.Time%35*210) == 0)
				{
				// could be better but unsure how
				players[i].mo.A_StartSound("corruptioncards/rain", CHAN_7, CHANF_LOCAL, rainvol[i], ATTN_NORM);
				}
				
				rainvol[i] = 0.0;
			}
		}
	}
}

Class CCards_Rain
{
	String translation;
	int duration;
//	bool isRaining;
}


Class CCards_RainDrop : Actor
{
	default
	{
		+MISSILE;
		+NOINTERACTION;
		xscale 1.0;
		yscale 6.0;
	}
	
	float yoff;
	float xoff;
	int playerno;
	CCards_WeatherManager weather;
	bool show;
	
	void Init()
	{
		if(!SetTargetPlayer())
		{
		return;
		}
		
		SetOffsets();
		SetOrigin((target.pos.x + xoff, target.pos.y + yoff, random(target.pos.z - 128.0, target.pos.z + 512.0)), false);
		A_ChangeVelocity(0, 0, -60.0, CVF_REPLACE);
	}
	
	states
	{
		Spawn:
		TNT1 A 0;
		TNT1 A 0 Init();
		Rain:
		RNDR A 1 Rain();
		loop;
	}
	
	void SetOffsets()
	{
		xoff = random(-800.0, 800.0);
		yoff = random(-800.0, 800.0);
	}
	
	void Rain()
	{	
		if(!target)
		{
			return;
		}
		
		if(!weather.showRaining)
		{
			A_SetRenderStyle(0.0, STYLE_Translucent);
			SetOrigin((target.pos.x + xoff, target.pos.y + yoff, random(target.pos.z - 128.0, target.pos.z + 512.0)), false);
			return;
		}
		
		if(!SetTargetPlayer())
		{
			A_SetRenderStyle(0.0, STYLE_Translucent);
			return;
		}
		
		A_SetTranslation(weather.translation);
		
		if(CheckSkyCeiling())
		{
			A_SetRenderStyle(1.0, STYLE_Translucent);
			
			if(pos.z <= floorz && show)
			{
				//Console.Printf("" .. (256.0 - Distance2D(target)));
				weather.SetRainVol(playerno, (Distance2D(target) * 0.001));
				Actor rfx = Spawn("CCards_Actor_RainFX", (pos.x, pos.y, floorz));
				rfx.translation = translation;
			}
		}
		else
		{
			A_SetRenderStyle(0.0, STYLE_Translucent);
		}
		
		if(pos.z < target.pos.z - 128.0 || pos.z < floorz || !Level.PointInSector((pos.x, pos.y)))
		{
			SetOffsets();
			SetOrigin((target.pos.x + xoff, target.pos.y + yoff, pos.z + 512.0), false);
			show = true;
		}
		else
		{
			SetOrigin((target.pos.x + xoff, target.pos.y + yoff, pos.z), false);
		}
	}
	
	bool CheckSkyCeiling()
	{
		return (TexMan.GetName(cursector.GetTexture(1)) == "F_SKY1");
	}
	
	bool SetTargetPlayer()
	{
		let p = players[playerno].mo;
		if(p)
		{
		target = p;
		return true;
		}
		return false;
	}
}

Class CCards_Actor_RainFX : CCards_Actor_FX
{
	Default
	{
		+FORCEYBILLBOARD;
	}

	states
	{
	Spawn:
	RNDR BCDEFGH 2 A_FadeOut(0.15);
	stop;
	}
}

Class CCard_NukageRain : Card
{
	CCards_WeatherManager weather;
	CCards_Rain rain;
	
	override void Init()
	{
	effectWorld = true;
	tier = 1;
	description = "Damaging acid rain will fall outside.";
	image = "CARD31";
	background = "CARB11";
	canStack = false;
	cardtag = TAG_WORLD;
	Addtag("hazard");
	Addtag("weather");
	}
	
	override bool Condition()
	{
		return CCards_WeatherManager.CheckValidSkySectors();
	}
	
	override void OnGameStart(Actor a)
	{
		weather = CCards_WeatherManager.Create();
		rain = new ("CCards_Rain");
		rain.translation = "CCards_NukageRain";
		rain.duration = 35*30;
		
		weather.NewRain(rain);
	}
	
	override void OnTick(Actor a)
	{
		if(!weather.CheckRain(rain)|| Level.Time % 35 != 0)
		{
			return;
		}
		
		CCards_PlayerThinker t;
		
		ThinkerIterator ti = ThinkerIterator.Create("CCards_PlayerThinker");
		
		while (t = CCards_PlayerThinker(ti.Next()))
		{	
			if(!t.user){continue;}
			
			for(int i = 0; i < level.sectors.size(); i++)
			{
				if(t.user.cursector == level.sectors[i] && IsSkySector(level.sectors[i]))
				{
					if(t.user.CountInv("PowerIronFeet")==0)
					{
						Actor rd = t.user.Spawn("CCards_Actor_RainDamager", t.user.pos);
						rd.master = t.user;
					}
					t.user.GiveInventory("CCards_Actor_RainDamaged", 1);
				}
			}
		}
	}
	
	bool IsSkySector (Sector s)
	{
		return TexMan.GetName(s.GetTexture(1)) == "F_SKY1";
	}
}


Class CCards_Actor_RainDamager : Actor
{
	Default
	{
		Obituary "%o could not find shelter from the acid rain.";
		+NODAMAGETHRUST;
	}
	
	states
	{
		Spawn:
		TNT1 A 0;
		TNT1 A 1 
		{
			master.DamageMobj(self, self, 5, "Slime", DMG_THRUSTLESS);
		}//A_DamageMaster((5), "Slime");
		stop;
	}
}

Class CCards_Actor_RainDamaged : PowerIronFeet
{
	Default
	{
	powerup.color "", 0.0;
	powerup.duration 35;
	}
}

Class CCard_SludgeRain : CCard_NukageRain
{		
	override void Init()
	{
	effectWorld = true;
	tier = 2;
	description = "Sludge rain will fall outside, slowing your movement.";
	image = "CARD35";
	background = "CARB11";
	canStack = false;
	cardtag = TAG_WORLD;
	Addtag("hazard");
	Addtag("weather");
	}
	
	override void OnGameStart(Actor a)
	{
		weather = CCards_WeatherManager.Create();
		rain = new ("CCards_Rain");
		rain.translation = "CCards_SludgeRain";
		rain.duration = 35*30;
		weather.NewRain(rain);
	}
	
	override void OnTick(Actor a)
	{
		if(!weather.CheckRain(rain) || Level.Time % (35*2) != 0)
		{
			return;
		}
		
		CCards_PlayerThinker t;
		
		ThinkerIterator ti = ThinkerIterator.Create("CCards_PlayerThinker");
		
		while (t = CCards_PlayerThinker(ti.Next()))
		{	
			if(!t.user){continue;}
			
			for(int i = 0; i < level.sectors.size(); i++)
			{
				if(t.user.cursector == level.sectors[i] && IsSkySector(level.sectors[i]))
				{
					t.user.GiveInventory("CCards_Actor_RainSludgeSlow", 1);
				}
			}
		}
	}
}

class CCards_Actor_RainSludgeSlow : PowerSpeed
{
	Default
	{
		Speed 0.56;
		PowerSpeed.NoTrail 1;
		powerup.duration -2;
	}
}

Class CCard_BloodRain : CCard_NukageRain
{		
	override void Init()
	{
	effectWorld = true;
	tier = 3;
	description = "Blood rain will fall outside, empowering monsters.";
	image = "CARD32";
	background = "CARB11";
	canStack = false;
	cardtag = TAG_WORLD;
	Addtag("allmonsters");
	Addtag("weather");
	}
	
	override void OnGameStart(Actor a)
	{
		weather = CCards_WeatherManager.Create();
		rain = new ("CCards_Rain");
		rain.translation = "CCards_BloodRain";
		rain.duration = 35*30;
		weather.NewRain(rain);
	}
	
	override void OnTick(Actor a)
	{
		if(!weather.CheckRain(rain) || Level.Time % (35*2) != 0)
		{
			return;
		}
		
		CCards_MonsterThinker t;
		
		ThinkerIterator ti = ThinkerIterator.Create("CCards_MonsterThinker");
		
		while (t = CCards_MonsterThinker(ti.Next()))
		{	
			if(!t.user){continue;}
			
			for(int i = 0; i < level.sectors.size(); i++)
			{
				if(t.user.cursector == level.sectors[i] && IsSkySector(level.sectors[i]) 
				&& t.user.health>0)
				{
					t.user.GiveInventory("CCards_Actor_BloodRainBuff", 1);
				}
			}
		}
	}
}

class CCards_Actor_BloodRainBuff : Powerup
{
	Default
	{
		powerup.duration -5;
	}

	override void DoEffect()
	{
		if(!owner)
		{
			return;
		}
		let time = Level.Time;

		if((time % 2)==0 && owner.CountInv("CCards_Actor_SpeedBuff") == 0)
		{
			if(owner.ResolveState("See") && owner.InStateSequence(owner.CurState, owner.ResolveState("See")))
			{
				owner.MonsterMove();
			}
		}

		if((time % 16) == 0 && !owner.CheckSightOrRange(1000, true) && CCards_ActorTools.IsVisible(owner))
		{
			owner.A_SpawnItemEx("CCards_Actor_BloodSmoke", 0, 0, (owner.height/3) * 2, 0, 0, 4);
		}

		Super.DoEffect();
	}

	override void ModifyDamage (int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		if (owner && !passive && damage > 0)
		{
			newdamage = max(1, ApplyDamageFactors(GetClass(), damageType, damage, damage * 2));
		}
	}
}

Class CCard_SpawnIllusions : Card
{
	override void Init()
	{
	effectWorld = true;
	tier = 2;
	description = "Add \"harmless\" illusions to the level.";
	image = "CARD44";
	background = "CARB32";
	canStack = false;
	cardtag = TAG_TRAP;
	Addtag("confusion");
	}

	int spawncount;
	Class<Actor> mon;
	Array<Class<Actor> > monsters;
	CCards_Safespawner spawner;

	override void OnGameStart(Actor a)
	{
		monsters.Clear();
		if(level.Total_Monsters > 0)
		{
			spawncount = Max(5, Min(level.Total_Monsters / 8, 30));
		}
		else
		{
			spawncount = 0;
		}
	}
	
	override void OnTick(Actor a)
	{
		if(spawncount > 0 && (Level.Time % 35) == 0)
		{
			if(monsters.Size() == 0)
			{
				GenerateMonsterArray();
				mon = PickRandomMonster();
			}

			if(mon)
			{
				if(!CCards_Functions.HasMapSpecial(mon))
				{
					CCards_Actor_SafeSpawner ss = CCards_Safespawner.New(mon.GetClassname(), 1, "CCards_Actor_ItemFog", 
					GetDefaultByType(mon).radius, GetDefaultByType(mon).height, 0, 1);
					if(ss)
					{
						ss.GiveInventory("CCards_Actor_IllusionBuff", 1);
					}
				}
			}
			mon = PickRandomMonster();
			spawncount--;
		}
	}

	Class<Actor> PickRandomMonster()
	{
		if(monsters.Size()==0)
		{
			return null;
		}
		return monsters[random(0, monsters.Size()-1)];
	}

	void GenerateMonsterArray()
	{
		monsters.Clear();
		ThinkerIterator ti = ThinkerIterator.Create("CCards_MonsterThinker");
				
		CCards_MonsterThinker t;
				
		while (t = CCards_MonsterThinker(ti.Next()))
		{
			if(t && t.user && CCards_Functions.IsLegalMonster(t.user))
			{
				bool dupe = false;

				if(monsters.Size()>0)
				{
					for(int i = 0; i<monsters.Size(); i++)
					{
						if(t.user.GetClassName() == monsters[i].GetClassName())
						{
							dupe = true;
							break;
						}
					}
				}
				monsters.Push(t.user.GetClass());
			}
		}		
	}
}

class CCards_Actor_IllusionBuff : Inventory
{
	override void DoEffect()
	{
		if(!owner.bISMONSTER)
		{
			return;
		}
		owner.A_ChangeCountFlags(0);
		owner.bNOBLOOD = true;
		owner.bNOPAIN = true;
		owner.bNOTARGETSWITCH = true;
		owner.bNOINFIGHTING = true;
		owner.bFULLVOLACTIVE = false;
		owner.bFULLVOLDEATH = false;
		owner.bBOSS = false;
	}

	override void ModifyDamage (int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		if (!passive && damage > 0)
		{
			newdamage = max(0, ApplyDamageFactors(GetClass(), damageType, 0, 0));
		}

		if (passive && damage > 0 && source && source.player)
		{
			newdamage = 0;

			for(int i = 0; i<4 + owner.radius / 10; i++)
			{
				owner.A_SpawnItemEx("CCards_Actor_Smoke", random(0, owner.radius/2), 0, random(8, owner.height+8), 1, 0, frandom(1, 3), random(0,360));
			}

			owner.A_SpawnItemEx("CCards_Actor_IllusionBreak");

			ThinkerIterator ti = ThinkerIterator.Create("Actor");
			
			Actor t;
				
			while (t = Actor(ti.Next()))
			{
				if(t && t.bMISSILE && t.target && t.target == owner)
				{
					t.A_SpawnItemEx("CCards_Actor_Smoke", 0);
					t.A_Remove(AAPTR_DEFAULT, RMVF_MISSILES);
				}
			}

			owner.A_Remove(AAPTR_DEFAULT);

			return;
		}
	}
}

class CCards_Actor_IllusionBreak : CCards_Actor_FX
{
	states
	{
		Spawn:
		TNT1 A 0;
		TNT1 A 35 A_StartSound("corruptioncards/illusionbreak");
		stop;
	}
}

Class CCard_HauntedHouse : Card
{
	mixin WorldEvent;

	bool isSpawning;
	bool finished;
	Vector3 pos;
	
	override void Init()
	{
	Super.Init();
	effectWorld = true;
	tier = 3;
	description = "You may be haunted by vengeful spirits.";
	image = "CARD48";
	canStack = true;
	cardtag = TAG_EVENT;
	Addtag("hiddensurprise");
	}
	
	override bool Condition()
	{	
		return (CCards_Functions.CountMonsters() > 1);
	}

	Array<Class<Actor> > monstertypes;
	
	override void OnGameStart(actor a)
	{
		monstertypes.Clear();

		Actor t;
		ThinkerIterator ti = ThinkerIterator.Create("Actor");
		
		while (t = Actor(ti.Next()))
		{
			if(!CCards_Functions.IsLegalMonster(t) || t.bBOSS || CCards_Functions.HasMapSpecial(t.GetClassName()))
			{
				continue;
			}

			if(monstertypes.Find(t.GetClass()) != monstertypes.Size())
			{
				continue;
			}

			monstertypes.Push(t.GetClass());
		}

		SetEventTotals();
		isSpawning = false;
		finished = false;
	}
	
	override void OnTick(actor a)
	{
		if(finished)
		{
			return;
		}
		
		if(EventTrigger())
		{
			finished = true;
			Actor p =  CCards_Functions.RandomPlayer();

			if(monstertypes.Size()==0 || !p)
			{
				return;
			}
			CCards_Functions.CardAlert("\ccThe dead are restless!", "corruptioncards/ghostspawn", 0);
			
			for(int i; i<5; i++)
			{
				for(int o; o<5; o++)
				{
					if(o == 2 && i == 2)
					{
						continue;
					}
					int r = random(0, monstertypes.Size()-1);
					
					float xoff = (i-2) * 800.0;
					float yoff = (o-2) * 800.0;

					Actor m = Actor.Spawn(monstertypes[r], (p.pos.x + xoff, p.pos.y + yoff, 0));
					m.bLOOKALLAROUND = true;
					m.bNOTARGETSWITCH = true;
					m.GiveInventory("CCards_Actor_Ghost", 1);
					m.target = p;
					m.lastheard = p;
					m.A_AlertMonsters(4, 0);
					m.health = m.default.health / 2;
				}
			}
		}
	}
}

Class CCard_Specialists : Card
{
	mixin WorldEvent;

	bool isSpawning;
	bool finished;
	Vector3 pos;
	String teamname;
	
	override void Init()
	{
	Super.Init();
	effectWorld = true;
	tier = 5;
	//description = "You will be attacked by the an elite team of monsters.";
	image = "TNT1A0";
	background = "CARD49";
	canStack = true;
	cardtag = TAG_EVENT;
	Addtag("newspawn");
	}

	Array<Class<Actor> > monstertypes;
	Array<Class<Actor> > team;

	int height, radius;
	
	override bool Condition()
	{	
		// Debug defaults
		description = Stringtable.Localize("$" .. "CC_HINT_SPECIALISTS1");
		description.Replace("#", "a team of monsters" .. "\c-");
		monstertypes.Clear();

		Actor t;
		ThinkerIterator ti = ThinkerIterator.Create("Actor");
		
		while (t = Actor(ti.Next()))
		{
			if(!CCards_Functions.IsLegalMonster(t) || t.bBOSS || CCards_Functions.HasMapSpecial(t.GetClassName()))
			{
				continue;
			}

			if(monstertypes.Find(t.GetClass()) != monstertypes.Size())
			{
				continue;
			}

			monstertypes.Push(t.GetClass());
		}

		if(monstertypes.Size() < 4)
		{
			return false;
		}

		while(team.Size() < 4)
		{
			int r = random(0, monstertypes.Size()-1);

			if(team.Find(monstertypes[r]) != team.Size())
			{
				continue;
			}

			team.Push(monstertypes[r]);
		}

		for(int i; i<monstertypes.Size(); i++)
		{
			int mradius = GetDefaultByType(monstertypes[i]).radius;
			int mheight = GetDefaultByType(monstertypes[i]).height;
			
			if(mradius > radius)
			{
				radius = mradius;
			}

			if(mheight > height)
			{
				height = mheight;
			}
		}
		teamname = CCards_NameGenerator.GetTeamName();
		//description = "You will be attacked by the " .. teamname .. "\c-!";
		description = Stringtable.Localize("$" .. "CC_HINT_SPECIALISTS1");
		description.Replace("#", teamname .. "\c-");
		

		return (team.Size() >= 4);
	}
	
	override void OnGameStart(actor a)
	{
		SetEventTotals();
		spawnedteam.Clear();
		isSpawning = false;
		finished = false;
		spawner = null;
	}

	CCards_Actor_SafeSpawner spawner;
	Array<Actor> spawnedteam;

	override void OnTick(actor a)
	{
		if((Level.Time % 35*3) == 0 && spawnedteam.Size()>0)
		{
			uint count = 0;

			for(int i = 0; i<spawnedteam.Size(); i++)
			{
				if(!spawnedteam[i] || spawnedteam[i].health < 1)
				{
					count++;
					continue;
				}
			}

			if(count>3)
			{
				spawnedteam.Clear();
				CCards_Functions.CardAlert("\c-The " .. teamname .. " \c-have been defeated!", "corruptioncards/assassindeath", 35*3);
				return;
			}
		}

		if(finished)
		{
			return;
		}
		
		if(EventTrigger() && !isSpawning)
		{
			if(team.Size()<4)
			{
				isSpawning = true;
				finished = true;
				return;
			}
			spawner = CCards_Safespawner.New("", 1, "", radius, height, 1300, 0);
			Actor p = CCards_Functions.RandomPlayer();
			if(p && spawner)
			{
				spawner.SetSpawnLocation(p);
			}
			isSpawning = true;
		}
		
		if(isSpawning)
		{
			if(spawner)
			{
				pos = spawner.pos;
			}
			else
			{
				Actor p = CCards_Functions.RandomPlayer();
				CCards_Functions.CardAlert("\c-The " .. teamname .. " \c-have arrived!", "corruptioncards/teamappear", 35*3);
				finished = true;

				spawnedteam.Clear();

				Actor tank = Actor.Spawn(team[0], pos);
				tank.GiveInventory("CCards_Actor_ProtectiveShieldBuff", 1);
				if(CCards_Observer.FindProjectileThrower(tank.GetClass()))
				{
					tank.GiveInventory("CCards_Actor_ProjectileModTriple", 1);
				}
				else
				{
					tank.GiveInventory("CCards_Actor_Cannibalism", 1);
				}
				tank.A_SetTranslation("CCards_SpecalistGreen");
				spawnedteam.Push(tank);

				Actor ninja = Actor.Spawn(team[1], pos);
				ninja.GiveInventory("CCards_Actor_SpeedBuff", 1);
				ninja.GiveInventory("CCards_Actor_NinjaBuff", 1);
				ninja.A_SetTranslation("CCards_SpecalistPurple");
				spawnedteam.Push(ninja);

				Actor aggro = Actor.Spawn(team[2], pos);
				aggro.bALWAYSFAST = true;
				aggro.A_ChangeVelocity(0, 0, 10);
				aggro.A_SetTranslation("CCards_SpecalistRed");
				if(!aggro.default.bFLOAT)
				{
					CCards_Actor_GenericFlight f = CCards_Actor_GenericFlight(aggro.Spawn("CCards_Actor_GenericFlight", aggro.pos));
					f.target = aggro;
					aggro.bFLOAT = true;
					aggro.bNOGRAVITY = true;
				}

				spawnedteam.Push(aggro);

				Actor prickly = Actor.Spawn(team[3], pos);
				prickly.GiveInventory("CCards_Actor_AcidBloodBuff", 1);
				//prickly.GiveInventory("CCards_Actor_Reflective", 1);
				if(CCards_Observer.FindProjectileThrower(prickly.GetClass()))
				{
					prickly.GiveInventory("CCards_Actor_ProjectileModHitscan", 1);
				}
				else
				{
					prickly.GiveInventory("CCards_Actor_BorrowedTimeBuff", 1);
				}
				prickly.A_SetTranslation("CCards_SpecalistBlue");
				spawnedteam.Push(prickly);

				for(int i; i<spawnedteam.Size(); i++)
				{
					spawnedteam[i].A_SetScale(spawnedteam[i].default.scale.x * 1.15, spawnedteam[i].default.scale.x * 1.15);
					spawnedteam[i].health = spawnedteam[i].default.health * 1.10;
					spawnedteam[i].GiveInventory("CCards_Actor_SolidHelper", 1);
					spawnedteam[i].bNOTARGET = true;
					spawnedteam[i].bNOINFIGHTING = true;
					spawnedteam[i].target = p;
					spawnedteam[i].lastheard = p;
					spawnedteam[i].speed += 2;
					spawnedteam[i].bDONTHARMSPECIES = true;
					spawnedteam[i].bTHRUSPECIES = true;
					spawnedteam[i].species = "CCards_Specialists";
					spawnedteam[i].painchance = spawnedteam[i].painchance / 2;
					spawnedteam[i].bNOBLOCKMONST = true;
					spawnedteam[i].GiveInventory("CCards_Actor_SpecialistDamageResist", 1);
					spawnedteam[i].bDONTSQUASH = true;
					spawnedteam[i].bDONTMORPH = true;
					if(spawnedteam[i].health < 150)
					{
						spawnedteam[i].health = 150;
					}
				}
			}
		}
	}
}

class CCards_Actor_SpecialistDamageResist : Inventory
{
	override void ModifyDamage (int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		if (owner && passive && damage > 0)
		{
			if(source && !source.player)
			{
				newdamage = 0;
				return;
			}
		}	
	}
}

Class CCard_UnfinishedBusiness : Card
{
	override void Init()
	{
	effectWorld = true;
	tier = 4;
	image = "TNT1A0";
	background = "CARD54";
	canStack = false;
	cardtag = TAG_EVENT;
	Addtag("startspawn");
	}

	int count;

	override bool Condition()
	{
		let m = CCards_MonsterCounter.Get();

		if(m && m.monsters.Size() >= 10)
		{
			return true;
		}

		return false;
	}

	Array<Class<Actor> > monsters;

	override void OnGameStart(Actor a)
	{
		count = 0;
		monsters.Clear();

		CCards_MonsterCounter m = CCards_MonsterCounter.Get();

		if(m)
		{
			monsters.Copy(m.monsters);
			m.monsters.Clear();
		}
	}

	override void OnTick(Actor a)
	{
		if(monsters.Size() == 0 || CCards_Functions.GetGameTime() < 35 * 10 || count > 100)
		{
			return;
		}

		if((Level.Time % (35*1)) == 0)
		{
			if(count == 0)
			{
				CCards_Functions.CardAlert("Monsters have followed you into the level...", "", 35*3);
			}

			if(!CCards_Functions.HasMapSpecial(monsters[monsters.Size() - 1]))
			{
				CCards_Safespawner.New(monsters[monsters.Size() - 1].GetClassName(), 1, "CCards_Actor_TeleportFogSound", 0, 0, 0, 4);
			}
			count++;
			monsters.Pop();
		}
	}
}


Class CCard_RescueMission : Card
{
	override void Init()
	{
	effectWorld = true;
	effectPlayers = true;
	tier = 2;
	image = "CARD57";
	background = "";
	canStack = false;
	cardtag = TAG_WORLD;
	}

	override bool Condition()
	{
		if(Level.Total_Secrets > 0 && Level.Total_Monsters > 0 && Level.LevelNum != 30)
		{
			return true;
		}

		return false;
	}

	bool daisyspawned;
	bool daisyfound;

	override void OnTick(Actor a)
	{
		if(!a)
		{
			return;
		}

		if(daisyfound)
		{
			if(a.CountInv("CCards_Actor_DaisyPunisher") > 0)
			{
				a.TakeInventory("CCards_Actor_DaisyPunisher", 999);
			}
			return;
		}
		if(a && daisyspawned && a.CountInv("CCards_Actor_DaisyPunisher") == 0)
		{
			a.GiveInventory("CCards_Actor_DaisyPunisher", 1);
			return;
		}
	}

	override void PreGameStart()
	{
		daisyspawned = false;
	}

	override void OnGameStart(Actor a)
	{
		if(a)
		{
			return;
		}

		ThinkerIterator ti = ThinkerIterator.Create("Actor");
		
		Actor t;

		Array<Actor> actors;
		Array<Actor> secretactors;

		while(t = Actor(ti.Next()))
		{
			Inventory i = Inventory(t);

			if((i && !i.owner)) 
			{
				actors.Push(t);
			}
		}

		for(int i; i<actors.size(); i++)
		{
			if(actors[i].cursector.IsSecret())
			{
				secretactors.Push(actors[i]);
			}
		}

		if(secretactors.Size() > 0)
		{
			Actor a = secretactors[random(0, secretactors.Size()-1)];
			if(a.CheckIfSeen())
			{
				SpawnDaisy(a);
			}
			return;
		}

		if(actors.Size() > 0)
		{
			Actor a = actors[random(0, actors.Size()-1)];
			if(a.CheckIfSeen())
			{
				SpawnDaisy(a);
			}
			return;
		}
	}

	void SpawnDaisy(actor a)
	{
		daisyfound = false;
		daisyspawned = true;
		CCards_Actor_Daisy d = CCards_Actor_Daisy(a.Spawn("CCards_Actor_Daisy", a.pos));
		d.card = self;
		a.Spawn("CCards_Actor_ItemFog", a.pos);
	}
}

class CCards_Actor_Daisy : Inventory
{
	CCard_RescueMission card;

	Default
	{
		height 52;
		radius 16;
		speed 4;
		scale 0.7;
		+BLOCKASPLAYER;
		-SOLID;
		+NOTELEPORT;
		+INVENTORY.QUIET;
		-CANUSEWALLS;
		-ACTIVATEMCROSS;
		activesound "corruptioncards/daisy";
	}

	states
	{
		Spawn:
		DBUN A 0 DaisyNoise();
		DBUN A 0 {speed = 4;}
		DBUN AAABBB 1 A_Wander();
		DBUN A 0 {speed = 3;}
		DBUN CCCDDD 1 A_Wander();
		loop;
	}

	void DaisyNoise()
	{
		double pitch = frandom(1.0, 1.2);

		if(random(0, 10) == 0)
		{
			A_StartSound("corruptioncards/daisy", pitch: pitch);
		}
		else
		{
			A_StartSound("corruptioncards/daisystep", CHAN_7, volume: 0.7, pitch: pitch);
		}
	}

	override void AttachToOwner(Actor other)
	{
		Super.AttachToOwner(other);
		if(card)
		{
			card.daisyfound = true;
			S_Sound("corruptioncards/daisyfound", CHAN_7);
			other.A_StartSound("corruptioncards/daisy");
			CCards_Functions.CardAlert("\cfDaisy has been found!", "", 35);
		}
		Destroy();
		return;
	}
}

class CCards_Actor_FakeDaisy : CCards_Actor_Daisy
{
	Default
	{
		Translation "CCards_WhiteRail";
	}
	
	override void AttachToOwner(Actor other)
	{
		other.A_StartSound("corruptioncards/daisy");
		Destroy();
		return;
	}
}

class CCards_Actor_DaisyPunisher : Inventory
{
	CCards_Game game;
	bool hasexited;

	override void Travelled()
	{	
		hasexited = true;
		Super.Travelled();
	}

	override void Tick()
	{
		if(hasexited && CCards_Functions.GetGameTime() == 35)
		{
			owner.Spawn("CCards_Actor_DaisyPunishment", owner.pos);
			Destroy();
			return;
		}

		Super.Tick();
		return;
	}
}

class CCards_Actor_DaisyPunishment : Actor
{
	Default
	{
		+NOINTERACTION;
		-SOLID;
	}

	states
	{
		Spawn:
		TNT1 A 0;
		TNT1 A 0
		{
			ThinkerIterator ti = ThinkerIterator.Create("CCards_Actor_DaisyPunishment");
			
			CCards_Actor_DaisyPunishment t;
			
			while (t = CCards_Actor_DaisyPunishment(ti.Next()))
			{
				if(t == self)
				{
					continue;
				}
				SetStateLabel("Death");
				return;
			}

			Punish();
			SpawnProp();
		}
		TNT1 A -1;
		Death:
		TNT1 A 0;
		stop;
	}

	void SpawnProp()
	{
		CCards_Actor_SafeSpawner spawner = CCards_Safespawner.New("CCards_Actor_DeadDaisyProp", 1, "", 0, 0, 128, 0);

		if(spawner)
		{
			Actor p = CCards_Functions.RandomPlayer();
			if(p)
			{
				spawner.SetSpawnLocation(p);
			}
		}
	}

	void Punish()
	{
		ThinkerIterator ti = ThinkerIterator.Create("CCards_MonsterThinker");
				
		CCards_MonsterThinker mt;

		int b = random(0, 20);
		bool announced;

		while (mt = CCards_MonsterThinker(ti.Next()))
		{
			Actor t = mt.user;

			if(t && CCards_Functions.IsLegalMonster(t) && t.health > 0)
			{
				String n = CCards_BuffManager.ApplySeededBuff(t, b);

				if(!announced)
				{
					CCards_Functions.CardAlert("\crYour despair over losing daisy empowers monsters in this level with " .. n .. "\cr!", "corrptioncards/daisyfail", 4*35);
					announced = true;
				}
			}
		}
		
	}
}

class CCards_Actor_DeadDaisyProp : Actor
{
	Default
	{
		-SOLID;
		scale 0.48;
		+MOVEWITHSECTOR;
		height 8;
		radius 16;
	}

	states
	{
		Spawn:
		DBUN M -1;
		stop;
	}
}


class CCards_Actor_TheAncientOne : Actor
{
	Default
	{
		+BOSS;
		-COUNTKILL;
		+ISMONSTER;
		+SHOOTABLE;
		+SOLID;
		height 100;
		radius 48;
		+NOINFIGHTING;
		+NOTARGET;
		+NOBLOOD;
		+NOICEDEATH;
		health 10000;
		+LOOKALLAROUND;
		+QUICKTORETALIATE;
		+SLIDESONWALLS
		+NORADIUSDMG;
		+DONTMORPH;
		+DONTDRAIN;
		+NOBLOCKMONST;
		+NOTELEFRAG;
		scale 0.6;
		bloodcolor "Gold";
		tag "The Ancient One";
		damagefactor "TheAncientOne", 0.0;
		obituary "%o was eradicated by the Ancient One.";
		maxstepheight 48;
		MaxDropOffHeight 48;
		speed 3;
		mass 9000;
		+BRIGHT;
		spriteangle 180;
	}

	CCards_SafespawnerCallback spawnercallback;
	uint sightcheck;

	states
	{
		Spawn:
		TNT1 A 0 SetStateLabel("Seek");
		TNT1 A 35
		{
			GiveInventory("CCards_Token_NotProjectileThrower", 1);
			CCard_TheAncientOne card = CCard_TheAncientOne(CCards_Functions.FindCardByName("CCard_TheAncientOne"));
			if(card)
			{
				health = health * (card.power + 1);
			}
			A_Quake(7, 40, 0, 4000, "");
			bSPRITEANGLE = true;
			bNODAMAGE = true;
			bSHOOTABLE = false;
		}
		TNT1 A 50
		{
			CCards_Functions.CardAlert("\ciThe Ancient One has awoken!", "", 0);
			S_Sound("corruptioncards/ancientonearrive", CHAN_VOICE, volume:0.5);
			A_SpawnItemEx("CCards_Actor_TheAncientOneIntroPortalFX", -1, 0, 64, flags:SXF_NOCHECKPOSITION);
			//A_SpawnItemEx("CCards_Actor_TheAncientOneIntroPortalFX", -1, 0, 64);
			
			A_SetRenderStyle(0.0, STYLE_Normal);
		}
		C_GL D 0 
		{
			A_Quake(2, 5, 0, 1200, "");
			bSHOOTABLE = true;
			A_StartSound("corruptioncards/ancientonesee", CHAN_7, attenuation:ATTN_NONE);
		}
		C_GL DEFG 14 A_FadeIn(0.1);
		C_GL D 0 
		{
			A_Quake(2, 5, 0, 1200, "");
			//A_PlaySound("corruptioncards/ancientonewalk", slot:CHAN_7, attenuation:0.25, pitch:frandom(1.0, 1.05));
		}
		C_GL HIBC 14 A_FadeIn(0.1);
		C_GL D 0 
		{	
			A_Quake(2, 5, 0, 1200, "");
			//A_PlaySound("corruptioncards/ancientonewalk", slot:CHAN_7, attenuation:0.25, pitch:frandom(1.0, 1.05));
		}
		C_GL DEFG 14 A_FadeIn(0.1);
		C_GL A 10
		{
			bNODAMAGE = false;
		}
		C_GL A 0
		{
			bSPRITEANGLE = false;
			lastheard = CCards_Functions.RandomPlayer();
		}
		Seek:
		C_GL A 10 A_Look;
		loop;
		See:
		C_GL HHHHIIIIBBBBCCCC 1 GolemChase();
		C_GL D 0 
		{
			A_PlaySound("corruptioncards/ancientonewalk", slot:CHAN_7, attenuation:0.85, pitch:frandom(1.0, 1.05));
			A_Quake(2, 5, 0, 700);
		}
		C_GL DDDDEEEEFFFFGGGG 1 GolemChase();
		C_GL D 0 
		{
			A_PlaySound("corruptioncards/ancientonewalk", slot:CHAN_7, attenuation:0.85, pitch:frandom(1.0, 1.05));
			A_Quake(2, 5, 0, 700);
		}
		loop;
		Melee:
		C_GL JKLM 2
		{
			A_FaceTarget();
			A_Recoil(-1);
		}
		C_GL N 5
		{
			A_Explode(128, 200, XF_NOTMISSILE, false, 0);
			A_Quake(7, 35, 0, 512, "");
			A_StartSound("corruptioncards/ancientonestomp", slot:CHAN_7, attenuation:0.25);
			if(Distance2D(target) < 100)
			{
				target.A_ChangeVelocity(0, 0, -50);
			}

			for(int i; i<20; i++)
			{
				A_SpawnItemEx("CCards_Actor_AncientOneDebris", frandom(64, 256), 0, 0, frandom(-2, 2), frandom(-2, 2), frandom(1, 10), random(-60, 60), SXF_TRANSFERALPHA);
			}
		}
		C_GL OP 4;
		C_GL Q 2;
		Goto See;
		Missile:
		C_GL L 0 
		{	
			A_Stop();
			A_FaceTarget();
			A_StartSound("corruptioncards/railcharge", slot:CHAN_7, attenuation:0.25);
		}
		C_GL LLLLL 4
		{
			A_SpawnItemEx("CCards_Actor_TheAncientOneBeamFX", 10, 0, 148);
			A_FaceTarget();
		}
		C_GL K 0 A_SpawnProjectile("CCards_Actor_TheAncientOneBeam", 55);
		C_GL KKKKKK 3
		{
			A_FaceTarget();
		}
		C_GL J 5;
		Goto See;
		Teleporting:
		TNT1 A 35
		{
			bSHOOTABLE = false;
			bTHRUACTORS = true;
			bINVULNERABLE = true;
			A_SetRenderStyle(0.0, STYLE_Normal);
		}
		C_GL A 0
		{
			bSHOOTABLE = true;
			bTHRUACTORS = false;
			bINVULNERABLE = false;
		}
		C_GL AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 1
		{
			A_FaceTarget();
			A_FadeIn(0.08);
		}
		Goto See;
		Death:
		C_GL R 70 
		{
			A_StartSound("corruptioncards/ancientonedeath", slot:CHAN_7, attenuation:ATTN_NONE);
			CCard_TheAncientOne card = CCard_TheAncientOne(CCards_Functions.FindCardByName("CCard_TheAncientOne"));

			if(card)
			{
				card.power++;
			}
		}
		C_GL RRRRRRRRRRRRRRRRRRRRRRRR 8
		{
			A_Quake(7, 10, 0, 1000, "");
			A_SpawnItemEx("CCards_Actor_TheAncientOneBeamExplosion", random(48, -48), 0, random(10, 100), 0, 0, 0, random(0,360), WARPF_NOCHECKPOSITION); 
			A_FadeOut(0.18);
		}
		stop;
	}

	void GolemChase()
	{	
		int dist = Distance2D(target);
		bool cansee = CheckSight(target);

		bFRIENDLY = false; // gods need not mortal allies

		if(!cansee)
		{
			sightcheck++;
		}
		else
		{
			sightcheck = 0;
		}

		if(sightcheck == 35*10 && !spawnercallback)
		{
			CCards_Actor_SafeSpawner s = CCards_Safespawner.New("CCards_Actor_TempSpawnSpot", 1, "", radius, height, radius, 4);
				
			if(!s)
			{
				//Console.Printf("piss!");
				return;
			}

			s.SetSpawnLocation(target);
			spawnercallback = new("CCards_SafespawnerCallback");
			s.spawnercallback = spawnercallback;
		}

		if(spawnercallback && spawnercallback.spawnedactor)
		{
			A_Stop();
			SetOrigin(spawnercallback.spawnedactor.pos, false);
			spawnercallback.spawnedactor.A_SpawnItemEx("CCards_Actor_TheAncientOneIntroPortalFXFast", -1, 0, 64, flags:SXF_NOCHECKPOSITION);
			A_SpawnItemEx("CCards_Actor_TheAncientOneIntroPortalFXFast", -1, 0, 64, flags:SXF_NOCHECKPOSITION);
			spawnercallback.spawnedactor.Destroy();
			spawnercallback = null;
			sightcheck = 0;
			SetStateLabel("Teleporting");
			return;
		}

		if(target && dist < 200 && cansee && target.health > 0)
		{
			A_ScaleVelocity(0.5);
			SetStateLabel("Melee");
			return;
		}

		if(GetAge() % 200 == 0)
		{	
			angle = random(0, 360);
		}

		A_Recoil(-1);
		A_Chase();
	}

	override void Tick()
	{
		if(GetAge() % 3 == 0 && (bSHOOTABLE || health < 1))
		{
			A_SpawnItemEx("CCards_Actor_TheAncientOneFX",0,0,5);
		}
		Super.Tick();
	}
}

class CCards_Actor_AncientOneDebris : CCards_Actor_StoneChunk
{
	Default
	{
		+MISSILE;
		scale 0.5;
	}
}

class CCards_Actor_TheAncientOneIntroPortalFX : CCards_Actor_FX
{
	Default
	{
		alpha 0.0;
		scale 2.0;
		Translation "CCards_TheAncientOne";
		renderstyle "Style_ADD";
		+ROLLSPRITE;
	}

	states
	{
		Spawn:
		C_F4 N 1
		{	
			roll += 10;
			if(GetAge() > 200)
			{
				A_FadeOut(0.1);
				return;
			}
			if(alpha < 0.8)
			{
				A_FadeIn(0.05);
			}
		}
		loop;
	}

	override void PostBeginPlay()
	{
		A_PlaySound("corruptioncards/ancientoneportal", attenuation:0.25);
	}
}

class CCards_Actor_TheAncientOneIntroPortalFXFast : CCards_Actor_TheAncientOneIntroPortalFX
{
	states
	{
		Spawn:
		C_F4 N 1
		{	
			roll += 10;
			if(GetAge() > 60)
			{
				A_FadeOut(0.1);
				return;
			}
			if(alpha < 0.8)
			{
				A_FadeIn(0.1);
			}
		}
		loop;
	}
}

class CCards_Actor_TheAncientOneFX : CCards_Actor_FX
{
	Default
	{
		Translation "CCards_TheAncientOne";
		renderstyle "STYLE_Add";
		scale 0.6;
		+MISSILE;
		+BRIGHT;
		alpha 0.9;
	}

	states
	{
		Spawn:
		TNT1 A 0;
		TNT1 A 0
		{
			if(!target)
			{
				Destroy();
				return;
			}

			spriteangle = target.spriteangle;
			bSPRITEANGLE = target.bSPRITEANGLE;
			sprite = target.sprite;
			frame = target.frame;
		}
		Fade:
		"####" "#" 1
		{
			A_SetScale(scale.x + 0.023, scale.y + 0.023);
			A_FadeOut(0.15);
			if(target)
			{
				Warp(target, flags:WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE);
			}
		}
		loop;
	}
}

class CCards_Actor_TheAncientOneBeamFX : CCards_Actor_FX
{
	Default
	{
		renderstyle "STYLE_Add";
		scale 0.5;
		Translation "CCards_TheAncientOne";
		+ROLLSPRITE;
		+BRIGHT;
	}

	states
	{
		Spawn:
		C_F4 I 1
		{
			roll = random(0,360);
			A_SetScale(scale.x + 0.3, scale.y + 0.3);
			A_FadeOut(0.1);
		}
		loop;
	}
}

class CCards_Actor_TheAncientOneBeam : Actor
{
	Default
	{
		PROJECTILE;
		+DONTREFLECT;
		Speed 70;
		Translation "CCards_TheAncientOne";
		+ROLLSPRITE;
		renderstyle "STYLE_Add";
		//+SEEKERMISSILE;
		radius 32;
		height 8;
		+BRIGHT;
		damage 10;
	}

	states
	{
		Spawn:
		C_F4 I 1
		{
			A_SpawnItemEx("CCards_Actor_TheAncientOneBeamFX");
			A_SpawnItemEx("CCards_Actor_TheAncientOneBeamFX", -8);
			A_SpawnItemEx("CCards_Actor_TheAncientOneBeamFX", -16);
			//A_SeekerMissile(2, 2);
			if(GetAge() % 3 == 1)
			{
				A_SpawnItemEx("CCards_Actor_TheAncientOneSigilFX");
			}
		}
		loop;
		Death:
		TNT1 A 0 A_SpawnItemEx("CCards_Actor_TheAncientOneBeamExplosion");
		DeathLoop:
		C_F4 H 1 
		{
			A_SetScale(scale.x + 0.3, scale.y + 0.3);
			roll = random(0, 360);
			A_FadeOut(0.05);
		}
		loop;
	}

	override void PostBeginPlay()
	{
		A_PlaySound("corruptioncards/ancientonefire", attenuation:0.25);
	}
}

class CCards_Actor_TheAncientOneBeamExplosion : CCards_Actor_FX
{
	Default
	{
		+MISSILE;
		scale 2.0;
		damagetype "TheAncientOne";
		Translation "CCards_TheAncientOne";
		renderstyle "STYLE_Add";
	}

	states
	{
		Spawn:
		TNT1 A 0;
		TNT1 A 0 
		{
			A_Explode(64, 180, 0);
			A_PlaySound("corruptioncards/ancientoneexplosion", attenuation:0.25);
		}
		C_F1 BCDEFGH 4;
		TNT1 A 10;
		stop;
	}

	override void Tick()
	{
		A_SetScale(scale.x + 0.18, scale.y + 0.18);
		A_FadeOut(0.01);
		Super.Tick();
	}
}

Class CCards_Actor_TheAncientOneSigilFX : CCards_Actor_FX
{
	Default
	{
		+WALLSPRITE;
		alpha 0.0;
		scale 0.25;
		Translation "CCards_TheAncientOne";
		renderstyle "Style_ADD";
		+ROLLSPRITE;
	}

	states
	{
		Spawn:
		TNT1 A 0;
		TNT1 A 0 
		{
			roll = random(0,360);
		}
		C_F4 NNNNNNN 1 A_FadeIn(0.2);
		C_F4 N 4;
		Death:
		C_F4 N 1 A_FadeOut(0.11);
		loop;
	}

	override void Tick()
	{	
		A_SetScale(scale.x + 0.1, scale.y + 0.1);
		Super.Tick();
	}
}

Class CCard_TheAncientOne : Card
{
	override void Init()
	{
	effectWorld = true;
	tier = 4; 
	background = "CARD92";
	image = "TNT1A0";
	cardtag = TAG_WORLD;
	AddTag("addspecialmonster");
	}

	uint power;
	Array<Actor> keepers;
	uint keepercount;

	override bool Condition()
	{
		if(Level.Total_Monsters < 20)
		{
			return false;
		}

		if(game.permanentChoice && game.global.collection.Size() < 20)
		{
			return false;
		}
		
		return true;
	}

	override void OnTick(Actor a)
	{
		if(CCards_Functions.GetGameTime() != 35)
		{
			return;
		}
		keepercount = 0;
		
		if(Level.Total_Monsters < 8)
		{
			return;
		}

		Array<Actor> monsters;

		Actor t;

		ThinkerIterator ti = ThinkerIterator.Create("Actor");

		while (t = Actor(ti.Next()))
		{
			if(!CCards_Functions.IsLegalMonster(t))
			{
				continue;
			}

			monsters.Push(t);
		}

		while(keepercount < 5)
		{
			if(monsters.Size() == 0)
			{
				break;
			}
			
			int r = random(0, monsters.Size() - 1);

			monsters[r].A_SpawnItemEx("CCards_Actor_KeeperIcon", flags:SXF_NOCHECKPOSITION);
			monsters[r].A_GiveInventory("CCards_Actor_NoMonsterDamage", 1);
			monsters[r].bNOINFIGHTING = true;
			keepercount++;
			monsters.Delete(r);
		}
	}

	void KeeperDied()
	{
		if(keepercount == 0)
		{
			return;
		}

		keepercount--;

		if(keepercount>0)
		{
			CCards_Functions.CardAlert("\cgA disciple was slain! Only \c-" .. keepercount .. "\cg left...", "corruptioncards/bloodscent", 35*2);
		}
		else
		{
			CCards_Functions.CardAlert("\cgAll disciples were slain...", "", 0);
			CCards_Actor_SafeSpawner spawner;
			spawner = CCards_Safespawner.New("CCards_Actor_TheAncientOne", 1, "", 64, 128, 128, 4);
			if(spawner)
			{
				spawner.SetSpawnLocation(CCards_Functions.RandomPlayer());
			}
		}
	}
}

Class CCards_Actor_KeeperIcon : CCards_Actor_FX
{
	Default
	{
		scale 0.5;
		+BRIGHT;
		+MISSILE;
	}

	states
	{
		Spawn:
		C_F4 O 1
		{
			if(target && target.health > 0)
			{
				int thez = target.pos.z + (target.height + 16);
				
				if(thez > target.ceilingz - 10)
				{
					thez = target.ceilingz - 10;
				}

				Warp(target, target.pos.x, target.pos.y, thez, flags:WARPF_ABSOLUTEPOSITION|WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE);
				A_SetScale(0.5 + cos(GetAge()*8) * 0.1, 0.5 + cos(GetAge()*8)  * 0.1);
			}
			else
			{
				SetStateLabel("Death");
				A_ChangeVelocity(0,0,0.1);
				A_SetScale(0.3, 0.3);
				A_StartSound("corruptioncards/illusionbreak");
			}
		}
		loop;
		Death:
		C_FX TUVWXYZ 3;
		TNT1 A 0
		{
			CCard_TheAncientOne card = CCard_TheAncientOne(CCards_Functions.FindCardByName("CCard_TheAncientOne"));

			if(card)
			{
				card.KeeperDied();
			}
		}
		stop;
	}
}

Class CCard_ChickenHazard : Card
{
	override void Init()
	{
	effectWorld = true;
	tier = 3;
	description = "Chickens will appear. Avoid killing them \cgat all costs.";
	background = "CARD40";
	image = "TNT1A0";
	canStack = false;
	cardtag = TAG_TRAP;
	}

	int spawncount;
	int killedchickens;
	int armageddontimer;

	bool KilledChicken()
	{
		killedchickens++;

		if(killedchickens >= 10 && armageddontimer == 0)
		{
			killedchickens = -9999;
			return true;
		}
		return false;
	}

	override void OnGameStart(Actor a)
	{
		killedchickens = 0;
		armageddontimer = 0;
		spawncount = Min((level.Total_Monsters)/4, 40);
	}
	
	override void OnTick(Actor a)
	{
		if(spawncount > 0 && (Level.Time % 2) == 0)
		{
			//for(int i = 0; i<min(10, spawncount); i++)
			//{
			CCards_Safespawner.New("CCards_Actor_Chicken", spawncount, "CCards_Actor_ItemFog", 28, 16, 0, 2);
			spawncount = 0;
			//spawncount--;
			//}
		}

		if(armageddontimer > 0)
		{
			armageddontimer--;
			if((Level.Time % 15) == 0)
			{
				for(int i=0; i<players.Size(); i++)
				{
					if(players[i].mo && players[i].mo.health>0)
					{
						int x = random(52, 128);
						int z = random(0, 64);
						int angle = random(0, 360);
						players[i].mo.A_SpawnItemEx("CCards_Actor_KillerChicken", x, 0, z, 0, 0, 0, angle, SXF_NOPOINTERS);
						players[i].mo.A_SpawnItemEx("CCards_Actor_ItemFog", x, 0, z, 0, 0, 0, angle);
					}
				}
			}

			if(armageddontimer == 0)
			{
				killedchickens = 0;
			}
		}
	}
}

class CCards_Actor_Chicken : Actor
{
	CCard_ChickenHazard card;

	Default
	{
		Health 19;
		Radius 8;
		Height 24;
		Mass 40;
		Speed 4;
		PainChance 256;
		Monster;
		-ISMONSTER;
		-COUNTKILL;
		+WINDTHRUST;
		+DONTMORPH;
		+FLOORCLIP;
		+FRIGHTENED;
		-NOBLOCKMONST;
		-ACTIVATEMCROSS;
		-SOLID;
		+DONTGIB;
		+NOTAUTOAIMED;
		damagefactor "Falling", 0.0;
		SeeSound "chicken/pain";
		AttackSound "chicken/active";
		PainSound "chicken/pain";
		DeathSound "chicken/death";
		ActiveSound "chicken/active";
		Obituary "%o was pecked to death by a vengeful chicken.";
		Tag "Chicken";
	}

	override void PostBeginPlay()
	{
		CCards_Game game = CCards_Functions.GetGame();

		for(int i; i<game.deck.Size(); i++)
		{
			if(game.deck[i] is "CCard_ChickenHazard")
			{
				card = CCard_ChickenHazard(game.deck[i]);
				break;
			}
		}

		super.PostBeginPlay();
	}

	States
	{
		Spawn:
		CHKN AB 10;
		See:
		CHKN AB 3 A_Wander;
		Loop;
		Panic:
		CHKN A 0 A_Feathers(random(1,4));
		CHKN AABB 1 A_Chase;
		loop;
		Pain:
		CHKN D 5 A_Feathers(1);
		CHKN C 5 A_Pain;
		CHKN A 0 {bDROPOFF = true;}
		Goto Panic;
		Death.Telefrag:
		TNT1 A -1;
		stop;
		Death:
		CHKN E 6 A_Scream;
		CHKN F 6 A_Feathers(1);
		CHKN G 6 A_Feathers(1);
		CHKN H 6 A_NoBlocking;
		CHKN IJK 6;
		CHKN L 1
		{
			if(card && card.KilledChicken())
			{
				SetStateLabel("Armageddon");
			}
		}
		CHKN L -1;
		Stop;
		Armageddon:
		CHKN L 90 
		{
			A_StartSound("chicken/death", CHAN_VOICE, CHANF_OVERLAP, 1.0, ATTN_NONE);
			CCards_Functions.CardAlert("\cgYou shouldn't have done that...", "corruptioncards/danger", 0);
			A_Quake(9, 30, 0, 1000, "");
		}
		CHKN L -1 
		{
			if(card)
			{
				card.armageddontimer = 35*30;
			}
		}
		stop;
	}

	void A_Feathers(int success)
	{
		if(success == 1)
		{
			A_SpawnItemEx("CCards_Actor_Feather", 0, 0, 0, frandom(1, 3), 0, frandom(1, 3), random(0,360));
		}
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if(source && !source.player)
		{
			damage = 0;
		}
		return Super.DamageMobj(inflictor, source, damage, mod, flags, angle);
	}
}

class CCards_Actor_KillerChicken : CCards_Actor_Chicken
{
	Default
	{
		gravity 0.25;
		+DROPOFF;
		-FRIGHTENED;
		+ALWAYSFAST;
		+NOINFIGHTING;
		+NOTARGET;
		damage 3;
		Tag "Vengeful Chicken";
	}

	int timeout;

	States
	{
		Spawn:
		CHKN A 0 DeathTimer();
		CHKN A 2 A_LookEx(0, 0, 0, 0, 360, "See");
		loop;
		See:
		CHKN A 0 DeathTimer();
		CHKN A 0 A_Feathers(random(0,2));
		CHKN AAABBB 1 A_Chase;
		Loop;
		Missile:
		CHKN A 0 DeathTimer();
		CHKN A 0 A_Feathers(random(0,2));
    	CHKN A 5 A_FaceTarget;
    	CHKN B 10 A_SkullAttack;
		Goto See;
		Pain:
		CHKN D 5 A_Feathers(1);
		CHKN C 5 A_Pain;
		Goto See;
		Death:
		CHKN E 6 A_Scream;
		CHKN F 6 A_Feathers(1);
		CHKN G 6 A_Feathers(1);
		CHKN H 6 A_NoBlocking;
		CHKN IJK 6;
		CHKN L -1;
		Stop;
	}

	void DeathTimer()
	{
		if(timeout == 0)
		{
			A_StartSound("misc/teleport", CHAN_AUTO);
		}
		timeout++;
		if(timeout > 35)
		{
			A_Die();
		}
	}
}

class CCards_Actor_Feather : Actor
{
	Default
	{
	Radius 2;
	Height 4;
	+MISSILE;
	+DROPOFF;
	+NOTELEPORT;
	+CANNOTPUSH;
	+WINDTHRUST;
	+DONTSPLASH;
	Gravity 0.125;
	}

	States
	{
		Spawn:
		CHKN MNOPQPON 3 
		{
			A_ScaleVelocity(0.7);
			if(GetAge() > 35 * 5)
			{
				Destroy();
				return;
			}
		}
		Loop;
		Death:
		CHKN N 6;
		Stop;
	}
}
