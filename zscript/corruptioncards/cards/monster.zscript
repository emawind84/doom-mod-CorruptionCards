// Monster related cards

Class CCard_MonsterHunt : Card
{
	override void Init()
	{
	effectMonsters = true;
	tier = 5;
	description = "Monsters begin hunting players from the start.";
	image = "CARD13";
	background = "CARB10";
	canStack = false;
	cardtag = TAG_MONSTER;
	}

	bool finished;
	
	override void OnGameStart(Actor a)
	{
		finished = false;
		
		if(a.bAMBUSH)
		{
			a.bAMBUSH = false;
		}
	}

	override void OnTick(Actor a)
	{
		if(finished)
		{
			return;
		}

		if(CCards_Functions.GetGameTime() > 35*10)
		{
			finished = true;
		}

		if(random(0, 5) != 0)
		{
			return;
		}
		
		if(!a.target || !a.lastheard)
		{
			a.target = CCards_Functions.RandomPlayer();
			a.lastheard = CCards_Functions.RandomPlayer();
		}
	}
}

Class CCard_GodMonster : Card
{
	Actor godActor;
	bool godChosen;
	uint totalmonsters;
	
	override void Init()
	{
	effectWorld = true;
	tier = 3; 
	description = "One monster is invulnerable until most monsters are slain.";
	image = "CARD23";
	background = "CARB09";
	cardtag = TAG_MONSTER;
	}

	override bool Condition()
	{
		return (CCards_Functions.CountMonsters() > 1);
	}

	override void OnGameStart(Actor a)
	{
		godChosen = false;
		totalmonsters = Level.Total_Monsters * 0.9;
	}

	override void OnTick(Actor a)
	{
		if(godChosen)
		{
			if(godActor)
			{
				if(godActor.health>0)
				{
					if(Level.Killed_Monsters >= totalmonsters - 1)
					{
						CCards_Functions.CardAlert("\cfThe Chosen One has become vulnerable!", "corruptioncards/godexposed");
						godActor.TakeInventory("CCards_Actor_MonsterGodMode", 9999);
						godActor = null;
						return;
					}
				}
				else
				{
					CCards_Functions.CardAlert("\cfThe Chosen One has been executed!", "corruptioncards/godexposed");
					godActor.TakeInventory("CCards_Actor_MonsterGodMode", 9999);
					godActor = null;
				}
			}

			return;
		}

		if(!godChosen && CCards_Functions.GetGameTime() == 35)
		{
			Array<Actor> monsters;
			Actor t;
			int largesthp;

			ThinkerIterator ti = ThinkerIterator.Create("Actor");

			while (t = Actor(ti.Next()))
			{
				if(!CCards_Functions.IsLegalMonster(t) || t.bBOSS || CCards_Functions.HasMapSpecial(t.GetClass()))
				{
					continue;
				}

				monsters.Push(t);
				largesthp = Max(largesthp, t.default.health);
			}

			while(monsters.Size()>0)
			{
				int r = random(0, monsters.Size()-1);

				if(!monsters[r])
				{
					monsters.Delete(r);
					continue;
				}

				if(monsters[r].health >= largesthp)
				{
					godActor = monsters[r];
					godActor.GiveInventory("CCards_Actor_MonsterGodMode", 1);
					godChosen = true;
					return;
				}

				largesthp = largesthp - (largesthp/2);
			}

			godChosen = true;
		}
	}
}

Class CCards_Actor_MonsterGodMode : PowerProtection
{
	uint oldtranslation;

	bool noblood;

	Default
	{
	powerup.duration 0x7FFFFFFF;
	}

	override void ModifyDamage (int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		if (passive && damage > 0)
		{
			newdamage = 0;

			Owner.A_StartSound("corruptioncards/godprotection", CHAN_BODY, CHANF_DEFAULT, 0.12, ATTN_NORM);

			if(source)
			{
				source.A_StartSound("corruptioncards/godprotection", CHAN_BODY, CHANF_LOCAL, 0.12, ATTN_NORM);
			}
		}
	}

	override void Tick()
	{
		if((Level.Time % 35) == 0)
		{
			owner.A_SetTranslation("CCards_GodMonster");
			owner.bSOLID = false;
		}

		if((Level.Time % 8) == 0)
		{
			owner.A_SpawnItemEx("CCards_Actor_GodFX", random(-owner.radius + 8, owner.radius + 8), zofs: random(0, owner.height+8), angle: random(0,360));
		}

		Super.Tick();
	}

	override void InitEffect() 
	{
		if(!owner)
		{
			Super.InitEffect();
			return;
		}
		oldtranslation = owner.translation;
		//owner.bINVULNERABLE = true;
		noblood = owner.bNOBLOOD;
		owner.bSOLID = false;
		owner.bNOBLOOD = true;
		owner.A_SetTranslation("CCards_GodMonster");
		owner.bNOTARGET = true;
		Super.InitEffect();
	}

	override void EndEffect()
	{
		if(!owner)
		{
			Super.EndEffect();
			return;
		}
		//owner.bINVULNERABLE = false;
		owner.translation = oldtranslation;
		owner.bSOLID = true;
		if(!noblood){owner.bNOBLOOD = false;}
		//owner.A_SetTranslation("");
		owner.bNOTARGET = false;	
		Super.EndEffect();
	}
}

class CCards_Actor_GodFX : CCards_Actor_FX
{
	Default
	{
		+BRIGHT;
		scale 1.0;
		alpha 0.9;
		translation "CCards_GodMonster";
	}
	
	states
	{
		Spawn:
		C_F2 MNOPQ 2;
		stop;
	}
}


Class CCard_CorpseExplode : Card
{	
	bool disabled;
	int power;

	override void Init()
	{
	effectMonsters = true;
	tier = 2;
	description = "Monsters explode violently on death.";
	image = "CARD05";
	background = "CARB09";
	canStack = true;
	cardtag = TAG_MONSTER;
	}
	
	override void OnGameStart(Actor a)
	{
		if(!isStackPrimary())
		{
			disabled = true;
		}
		else
		{
			power = stackIndex;
		}
		
	}
	
	override void OnDeath(Actor a)
	{
		if(disabled || a.health<-99999)
		{
			return;
		}

		let ex = CCards_Actor_DeathExplosion(Actor.Spawn("CCards_Actor_DeathExplosion", a.pos));
		ex.target = a;
		ex.power = power;
	}
}

Class CCards_Actor_DeathExplosion : Actor
{
	int power;

	Default
	{
	//projectile;
	+MISSILE
	+NOINTERACTION
	-SOLID
	+THRUACTORS
	+NOTARGET
	+BRIGHT;
	radius 2;
	height 2;
	xscale 0.75;
	yscale 0.75;
	obituary "%o got too close to an exploding monster.";
	DamageType "DeathExplosionCard";
	renderstyle "STYLE_Translucent";
	Alpha 0.8;
	}
	
	states
	{
		Spawn:
		TNT1 A 0;
		TNT1 A 0
		{
			if(target)
			{
				A_Warp(AAPTR_TARGET, 0, 0, 32, 0, WARPF_NOCHECKPOSITION);
			}
		}
		TNT1 A 10;
		TNT1 A 0
		{
			if(!target)
			{
				SetStateLabel("End");
				return;
			}
		}
		Explode:
		TNT1 A 0 
		{
		A_StartSound("world/barrelx", CHAN_AUTO);

		scale.x = scale.x + (0.5 * power);
		scale.y = scale.y + (0.5 * power);

		if(target)
		{
			if(target.CountInv("CCards_Actor_MiniMonsterPowerup") > 0)
			{
				scale.x = scale.x / 2;
				scale.y = scale.y / 2;
				power = power / 2;
				A_Warp(AAPTR_TARGET, 0, 0, 16, 0, WARPF_NOCHECKPOSITION);
			}
			else
			{
				A_Warp(AAPTR_TARGET, 0, 0, 32, 0, WARPF_NOCHECKPOSITION);
			}
		}
		target = null; 
		bMISSILE = false;
		}
		C_F0 G 8 Bright Light ("CC_ROCKET_X1") A_Explode(35 + (8 * power), 150 + (50 * power), XF_NOTMISSILE);
	    C_F0 H 6 Bright Light ("CC_ROCKET_X2");
   		C_F0 I 4 Bright Light ("CC_ROCKET_X3");
		Stop;
		End:
		TNT1 A 0;
		stop;
	}
}

Class CCard_Revenge : Card
{
	bool disabled;

	override void Init()
	{
	effectMonsters = true;
	tier = 4;
	description = "A monster will spawn every 16th kill.";
	image = "CARD18";
	background = "CARB10";
	canStack = true;
	cardtag = TAG_MONSTER;
	}
	
	Array<Class<Actor> > monsters;
	Class<Actor> nextmon;

	bool triggered;

	override bool Condition()
	{
		return (Level.Total_Monsters > 16 || game.permanentChoice);
	}

	override void PreGameStart()
	{
		triggered = false;
	}

	override void OnGameStart(Actor a)
	{
		if(!isStackPrimary())
		{
		disabled = true;
		return;
		}

		if(triggered)
		{
			return;
		}

		triggered = true;

		ThinkerIterator ti = ThinkerIterator.Create("Actor");
			
		Actor t;
			
		while (t = Actor(ti.Next()))
		{
			if(CCards_Functions.IsLegalMonster(t) && t.health>0 && !t.bBOSS)
			{
				if(monsters.Find(t.GetClass()) == monsters.Size())
				{
//					Console.Printf(t.GetClassNAme());
					monsters.Push(t.GetClass());
				}
			}
		}
	}

	override void OnDeath(Actor a)
	{
		if(disabled || a.CountInv("CCards_Token_NoRevenge") > 0)
		{
			return;
		}

		if(a.target && a.target.player)
		{
			a.target.A_GiveInventory("CCards_Actor_RevengeCount");

			if(a.target.CountInv("CCards_Actor_RevengeCount")>=16)
			{
				a.A_SpawnItemEx("CCards_Actor_RevengeFX");
				for(int i; i<stackIndex+1; i++)
				{
					if(monsters.Size()==0)
					{
						return;
					}

					nextmon = monsters[random(0, monsters.Size()-1)];

					if(CCards_Functions.HasMapSpecial(nextmon))
					{
						return;
					}

					int monradius = GetDefaultByType(nextmon).radius;
					int monheight = GetDefaultByType(nextmon).height;

					CCards_Actor_SafeSpawner spawner = CCards_Safespawner.New(nextmon.GetClassName(), 1, "CCards_Actor_RedTeleportFog", monradius, monheight, 600, 4);
					spawner.GiveInventory("CCards_Token_NoRevenge", 1);
					spawner.maxsteps = 1;
					spawner.SetSpawnLocation(a);
					spawner.target = a.target;
				}

				a.target.A_TakeInventory("CCards_Actor_RevengeCount", 16);
			}
		}
	}
}

Class CCards_Token_NoRevenge : CCards_Token {}

Class CCards_Actor_RevengeFX : CCards_Actor_FX
{
	States
	{
		Spawn:
		TNT1 A 0;
		TNT1 AA 3 SpawnFX();
		TNT1 A 0 A_Quake(3, 15, 0, 512, "");
		TNT1 A 0 A_StartSound("corruptioncards/revengeeffect", ATTN_NONE);
		TNT1 A 0 A_SpawnItemEx("CCards_Actor_RevengeSkullFX", 0, 0, 0, 0, 0, 8);
		TNT1 AAAAAAA 3 SpawnFX();
		TNT1 A 35;
		stop;
	}

	void SpawnFX()
	{
		if(target)
		{
			A_Warp(AAPTR_TARGET, flags: WARPF_NOCHECKPOSITION);
		}
		for(int i; i<2; i++)
		{
			A_SpawnItemEx("CCards_Actor_RevengeSmokeFX", 0, 0, 0, random(0, 2), 0, random(5, 10), random(0,360));
		}
	}
}

Class CCards_Actor_RevengeSkullFX : CCards_Actor_FX
{
	Default
	{
		xscale 0.5;
		yscale 2.0;
		+BRIGHT;
		translation "CCards_Anger";
		alpha 0.75;
	}

	states
	{
		Spawn:
		C_F1 Z 1
		{
			A_SetScale(scale.x + 0.05, scale.y - 0.005);
			A_FadeOut(0.018);
			A_ScaleVelocity(0.85);
		}
		loop;
	}
}


Class CCards_Actor_RevengeSmokeFX : CCards_Actor_BloodSmoke 
{
	Default
	{
		renderstyle "STYLE_Add";
		+BRIGHT;
		scale 0.025;
		alpha 0.5;
	}
}

Class CCards_Actor_RevengeCount : Inventory 
{
	Default
	{
	inventory.maxamount 1000;
	}
}

Class CCard_DisableInfight : Card
{
	override void Init()
	{
	effectMonsters = true;
	tier = 5;
	description = "Monsters no longer infight.";
	image = "CARD14";
	background = "CARB52";
	canStack = false;
	cardtag = TAG_MONSTER;
	}
	
	override void OnSpawn(Actor a)
	{
		a.bNOINFIGHTING = true;
	}
	
	override void OnRespawn(Actor a)
	{
		OnSpawn(a);
	}
}

Class CCard_MonsterDisguise : Card
{
	Array<String> disguises;
		
	override void Init()
	{
		effectMonsters = true;
		tier = 2;
		description = "Monsters are disgusied as items.";
		image = "CARD06";
		background = "CARB09";
		canStack = false;
		cardtag = TAG_MONSTER;
	}
	
	override bool Condition()
	{
		ThinkerIterator ti = ThinkerIterator.Create("Actor");
			
		Actor t;
		int count;
		
		while (t = Actor(ti.Next()))
		{	
			if(t.bAMBUSH)
			{
				count++;
			}
		}
		
		if(count>5)
		{
			FindDisguises();
			
			if(disguises.Size()>0)
			{
				return true;
			}
		}
		
		return false;
	}
	
	void FindDisguises()
	{
		disguises.Clear();
		
		ThinkerIterator ti = ThinkerIterator.Create("Inventory");
			
		Actor t;
		
		while (t = Actor(ti.Next()))
		{	
			if(t is "Inventory")
			{
				// CustomInventory items that spawn things and do other jank will have odd effects, including crashing
				if((t is "Health" || t is "Ammo" || t is "Weapon") && !Inventory(t).owner)
				{
					disguises.Push(t.GetClassName());
				}
			}
		}
	}
	
	override void PreGameStart()
	{
		FindDisguises();
	}
	
	override void OnTick(Actor a)
	{
		if(disguises.Size()==0)
		{
		return;
		}
		
		if(a.bAMBUSH && random(0,1) == 1 && a.CountInv("CCards_DisguiseTrigger")==0)
		{
			CCards_Actor_MonsterDisguise d = CCards_Actor_MonsterDisguise(a.Spawn("CCards_Actor_MonsterDisguise", a.pos));
			
			let dis = disguises[random(0, disguises.Size()-1)];
			
			if(!dis)
			{
				return;
			}
			
			d.FakePickup = dis;
			d.master = a;
			d.malpha = a.alpha;
			d.mstyle = a.GetRenderstyle();
			d.mshootable = a.bSHOOTABLE;
			d.msolid = a.bSOLID;
			a.Deactivate(a);
		}
		a.GiveInventory("CCards_DisguiseTrigger", 1);
	}
}

class CCards_DisguiseTrigger : Inventory {}

class CCards_Actor_MonsterDisguise : Actor
{
	String FakePickup;
	Actor fakeActor;
	float malpha;
	int mstyle;
	
	bool mShootable;
	bool mSolid;
	
	Default
	{
		+SOLID;
		+SHOOTABLE;
		+NORADIUSDMG;
		+SHADOW;
		height 32;
		radius 16;
		health 1;
		renderstyle "STYLE_NONE";
		tag " ";
	}
	
	states
	{
		Spawn:
		TNT1 A 1;
		TNT1 A 0
		{
			if(!master)
			{
			SetStateLabel("End");
			return;
			}
			fakeActor = Spawn(FakePickup, pos);
			fakeActor.bNOINTERACTION = true;
			A_SetSize(master.radius, master.height, false);
			master.bSHOOTABLE = false;
			master.bSOLID = false;
			master.bDORMANT = true;
			master.deactivate(master);
		}
		goto Seek;
		Seek:
		TNT1 A 1
		{	
			if(!master)
			{
			SetStateLabel("End");
			return;
			}
			master.bNOCLIP = true;
			master.deactivate(master);
			master.A_SetRenderStyle(0, STYLE_NONE);
 			if(fakeActor)
            {
            fakeActor.SetXYZ(pos);
            }
			else
			{
			SetStateLabel("See");
			return;
			}


			A_LookEx(LOF_NOSOUNDCHECK, 0, 32 + master.radius, 0, 360, "See");
		}
		loop;
		See:
		TNT1 A 0
		{
			if(!master)
			{
			SetStateLabel("End");
			return;
			}
			master.reactiontime = 5;
		}
		Death:
		TNT1 A 1
		{
			master.bNOCLIP = false;
			master.bSHOOTABLE = mShootable;
			master.bSOLID = mSolid;
			master.bLOOKALLAROUND = true;
			master.Activate(master);
			master.bDORMANT = false;
			master.A_SetRenderStyle(malpha, mstyle);
			//master.A_TakeInventory("CCards_DisguiseTrigger", 1);
			if(fakeactor)
			{
			master.SetOrigin(fakeActor.pos, true);
			fakeActor.Destroy();
			}
		}
		End:
		TNT1 A 0;
		stop;
	}
}

Class CCard_MonsterAOEHeal : Card
{
	override void Init()
	{
	effectMonsters = true;
	tier = 3;
	description = "Monsters heal nearby monsters on death.";
	image = "CARD21";
	background = "CARB27";
	canStack = false;
	cardtag = TAG_MONSTER;
	}
	
	override void OnDeath(Actor a)
	{
		BlockThingsIterator bti = BlockThingsIterator.Create(a, 256);
		
		while (bti.Next())
		{
			let next = bti.Thing;
			
			if(next && CCards_Functions.IsLegalMonster(next) && next.health > 0)
			{
				if(next.health > CCards_Functions.GetMaxHealth(next))
				{
					continue;
				}
				next.health = min(CCards_Functions.GetMaxHealth(next), next.health + 90);
				next.Spawn("CCards_Actor_HealFXSpawner", next.pos);
				Actor fx = a.Spawn("CCards_Actor_GivingHealFXSpawner", a.pos);
				fx.master = next;
				fx.target = a;
			}
		}
	}
}

class CCards_Actor_GivingHealFXSpawner : CCards_Actor_FX 
{ 
	default
	{
	//+MISSILE;
	height 1;
	radius 1;
	}
	states 
	{ 
	Spawn:
	TNT1 AAAAA 5 
	{
		A_Warp(AAPTR_TARGET, flags:WARPF_NOCHECKPOSITION);
		if(master)
		{
		Actor p = A_SpawnProjectile("CCards_Actor_AOEHealFX", spawnheight:random(0, 16), 0, pitch:16, ptr:AAPTR_MASTER);
		p.master = master;
		}
	}
	stop;
	Death:
	TNT1 A 0;
	stop;
	}
}

class CCards_Actor_HealFXSpawner : CCards_Actor_FX 
{ 

	states 
	{ 
	Spawn:
	TNT1 A 5;
	TNT1 AAAAA 2 A_SpawnItemEx("CCards_Actor_AOEHealFX", xofs:radius + random(0, 5), zofs:random(0, 16), zvel:random(1, 2), angle:random(0,360));
	stop;
	}
}

class CCards_Actor_AOEHealFX : CCards_Actor_FX
{
	default
	{
	speed 5;
	+NOINTERACTION;
	+BRIGHT;
	+NOGRAVITY;
	-ALLOWPARTICLES;
	+CLIENTSIDEONLY;
	+MISSILE;
	renderstyle "STYLE_Add";
	alpha 0.5;
	}
	
	states
	{
	Spawn:
	BLUD CCCCCCCCBBBBBBBBAAAAAAAA 1
	{	
		if(master)
		{
			if(Distance2D(master)<18)
			{
				SetStateLabel("Death");
			}
		}
	}
	stop;
	Death:
	TNT1 A 0;
	stop;
	}
}

Class CCard_DiseasedMonsters : Card
{
	override void Init()
	{
	effectMonsters = true;
	tier = 1;
	description = "Some monsters leave behind toxic corpses.";
	image = "CARD28";
	background = "CARB01";
	canStack = false;
	cardtag = TAG_MONSTER;
	}
	
	int fxcap;
	int power;
	bool disabled;
	
	override void OnGameStart(actor a)
	{
		if(!isStackPrimary())
		{
		disabled = true;
		}
		else
		{
		power = stackIndex;
		}
	}
	
	override void OnDeath(Actor a)
	{
		if(disabled)
		{
		return;
		}
		
		if(random(0, 3)==0)
		{
		CCards_Actor_PosionCorpse p = CCards_Actor_PosionCorpse(a.Spawn("CCards_Actor_PosionCorpse", a.pos));
		p.target = a;
		p.power = power;
		
			if(fxcap<100)
			{
			fxcap++;
			p.allowfx = true;
			}
		}
	}
}

class CCards_Actor_PosionCorpse : Actor
{
	bool allowfx;
	
	default
	{
	+NOINTERACTION;
	+MISSILE;
	-SOLID;
	}
	
	int fxcount;
	int timer;
	int power;
	
	states
	{
	Spawn:
	TNT1 A 10;
	Poison:
	TNT1 A 0
	{
		if(!target || target.CountInv("CCards_IsPoisonCorpse")>0)
		{
			SetStateLabel("End");
			return;
		}

		target.GiveInventory("CCards_IsPoisonCorpse", 1);
		target.A_SetTranslation("CCards_Poison");
	}
	Poisonloop:
	TNT1 A 1
	{
		timer++;
		if(!target || timer > 15*35)
		{
			SetStateLabel("End");
			return;
		}

		Warp(target, flags:WARPF_NOCHECKPOSITION|WARPF_USECALLERANGLE);
		
		if(true)
		{
			for(int i; i<players.Size(); i++)
			{
				Actor player;

				if(players[i].mo)
				{
					player = players[i].mo;
				}
				else
				{
					continue;
				}

				if(player && Distance3D(player) < 80 && player.CountInv("PowerIronFeet") == 0)
				{
					if((Level.Time % 17) == 0)
					{
						player.A_DamageSelf(random(2, 4) * (power+1), "CardPoison");
						player.A_GiveInventory("CCards_Actor_PosionProtection", 1);
					}
					player.A_GiveInventory("CCards_Actor_PosionFade", 1);
				}
			}
		}
		
		fxcount++;
		
		if(fxcount >= random(20, 25))
		{
			A_SpawnItemEx("CCards_Actor_PosionCorpseFX", random(2, radius), 0, 10, 0, 0, frandom(0.8, 1.0), random(0, 360));
			fxcount = 0;
		}
	}
	loop;
	End:
	TNT1 A 0;
	stop;
	}
}

class CCards_Actor_PosionFade : Powerup
{
	Default
	{
		powerup.color "00FF00", 0.25;
		powerup.duration 2;
		+inventory.NOSCREENBLINK;
	}
}

class CCards_Actor_PosionProtection : PowerProtection
{
	Default
	{
		DamageFactor "CardPoison", 0.0;
		powerup.duration 16;
	}
}

class CCards_Actor_PosionCorpseFX : CCards_Actor_FX
{
	Default
	{
		Renderstyle "Translucent";
		Alpha 0.6;
		Translation "CCards_Poison";
		scale 0.35;
		+NOGRAVITY;
		+MISSILE;
	}
	
	states
	{
		Spawn:
		C_F1 EEEFFFGGGGHHHHHHHH 4
		{
		A_FadeOut(0.1);
		A_SetScale(scale.x + 0.02, scale.y + 0.02);
		}
		stop;
	}
}

class CCards_IsPoisonCorpse : Inventory {}

Class CCard_IconsBlessing : Card
{
	int counter;
	
	override void Init()
	{
	effectMonsters = true;
	tier = 4;
	description = "Several monsters recieve a random card enchantment.";
	image = "CARD29";
	background = "CARB24";
	canStack = false;
	cardtag = TAG_MONSTER;
	}
	
	override void PreGameStart()
	{
		counter = 0;
	}
	
	override void OnGameStart(Actor a)
	{
		if(counter>2)
		{
			counter = 0;
		}

		if(counter>0)
		{
			counter++;
			return;
		}
		
		CCards_BuffManager.ApplyRandomBuff(a);
	}
}

Class CCard_MonsterShuffle : Card
{
	Array<Actor> monsterlist;
	
	override void Init()
	{
	effectWorld = true;
	tier = 4;
	description = "Monster starting positions are shuffled.";
	image = "CARD10";
	background = "CARB29";
	canStack = false;
	cardtag = TAG_WORLD;
	}
	
	override bool Condition()
	{
		return true;
	}
	
	override void OnGameStart(Actor a)
	{
		monsterlist.Clear();

		ThinkerIterator ti = ThinkerIterator.Create("CCards_MonsterThinker");
		
		CCards_MonsterThinker t;
		
		while (t = CCards_MonsterThinker(ti.Next()))
		{	
			if(t && t.user && CCards_Functions.IsLegalMonster(t.user))
			{
				monsterlist.Push(t.user);
			}
		}
		
		int i;

		while(monsterlist.Size()>1)
		{
			i = random(0, monsterlist.Size()-2);
			Actor selectedmon = monsterlist[monsterlist.Size()-1];
			for(int s=0; s<1000; s++)
			{
				Actor trymon = monsterlist[i];
				
				if(selectedmon && trymon)
				{
					if(SwapPos(selectedmon, trymon))
					{
						break;
					}
				}
			}
			monsterlist.Delete(i);
			monsterlist.Delete(monsterlist.Size()-1);
		}
	}
	
	bool SwapPos(actor a, actor b)
	{
		if(a.GetclassName() == b.GetClassName())
		{
			return false;
		}
	
		if(CCards_Functions.HasMapSpecial(a.GetClass()) || CCards_Functions.HasMapSpecial(b.GetClass()))
		{
			return false;
		}

		Vector3 apos = a.pos;
		Vector3 bpos = b.pos;
		float aangle = a.angle;
		float bangle = b.angle;
		bool aambush = a.bAMBUSH;
		bool bambush = b.bAMBUSH;
			
		bool blocked;
		a.SetOrigin(bpos, false);
		b.SetOrigin(apos, false);

		if(a.CheckBlock() || b.CheckBlock() || 
		!CCards_Safespawner.CheckCorners(a.pos, a.radius) || 
		!CCards_Safespawner.CheckCorners(b.pos, b.radius))
		{
			a.SetOrigin(apos, false);
			b.SetOrigin(bpos, false);
			return false;
		}
		
		a.angle = bangle;
		b.angle = aangle;
		
		a.bAMBUSH = bambush;
		b.bAMBUSH = aambush;
		
		return true;
	}
}

Class CCard_KeysOfPower : Card
{
	Array<String> Keynames;

	override void Init()
	{
	effectWorld = true;
	tier = 4;
	description = "Collecting keys gives monsters a random card enchantment.";
	image = "CARD34";
	canStack = false; // not enough buffs
	cardtag = TAG_MONSTER;
	}

	override bool Condition()
	{
		ThinkerIterator ti = ThinkerIterator.Create("Actor");
		Actor t;

		while(t = Actor(ti.Next()))
		{
			if(Actor.GetReplacee(t.GetClassName()) is "Key")
			{
				return true;
			}
		}
		return false;
	}
	
	override void PreGameStart()
	{
		Keynames.Clear();
	}

	override void OnTick(Actor a)
	{
		if((Level.Time % 35) == 0)
		{
			ThinkerIterator ti = ThinkerIterator.Create("Key");
				
			Key t;

			bool hasbuffed = false;
				
			while (t = Key(ti.Next()))
			{
				Inventory inv = Inventory(t);

				if(inv && inv.owner && inv.owner.player)
				{
					if(keynames.Find(inv.GetClassName()) == keynames.Size())
					{
						keynames.Push(inv.GetClassName());

						if(CCards_Functions.GetGameTime() < 35 * 2)
						{
							return;
						}
						
						if(!hasbuffed)
						{
							hasbuffed = true;
							BuffMonsters();
						}
					}
				}
			}
		}
	}
	
	void BuffMonsters()
	{	
		ThinkerIterator ti = ThinkerIterator.Create("CCards_MonsterThinker");
				
		CCards_MonsterThinker mt;
		bool announced;
		int n = random(0, 20);

		while (mt = CCards_MonsterThinker(ti.Next()))
		{
			Actor t = mt.user;

			if(t && CCards_Functions.IsLegalMonster(t) && t.health > 0)
			{
				String buffname = CCards_BuffManager.ApplySeededBuff(t, n);

				if(!announced)
				{
					CCards_Functions.CardAlert("\cfThe key empowered monsters with " .. buffname .. "\cf!", "corruptioncards/select");
					announced = true;
				}
			}
		}
	}
}

Class CCard_ResurrectionGift : Card
{
	override void Init()
	{
	Super.Init();
	tier = 5;
	effectMonsters = true;
	description = "Respawned enemies recieve a random card enchantment.";
	background = "CARB04";
	image = "CARD01";
	canStack = false;
	cardtag = TAG_MONSTER;
	}
	
	bool CheckResurrectMonsters (void)
	{
		if(CCards_Functions.FindCardWithTag("resurrection"))
		{
			return true;
		}

		for(int i; i<game.gen.mapmonsters.Size(); i++)
		{
			if(game.gen.mapmonsters[i].ResolveState("Heal"))
			{
				return true;
			}
		}

		return false;
	}

	override bool Condition()
	{
		if(CheckResurrectMonsters())
		{
			return true;
		}
		return false;
	}

	override void OnRespawn(Actor a)
	{
		CCards_BuffManager.ApplyRandomBuff(a);
	}

	override void OnSpawn(Actor a)
	{
		if(a.CountInv("CCards_Actor_9LivesCounter") > 0)
		{
			OnRespawn(a);
		}
	}
}


Class CCard_SealedMonster : Card
{
	override void Init()
	{
	Super.Init();
	effectPlayers = true;
	description = "Revealing a secret will spawn a monster.";
	image = "CARD41";
	background = "CARB30";
	canStack = true;
	tier = 3;
	cardtag = TAG_EVENT;
	}

	uInt maxhp;
	Array<uInt> playersecrets;
	Array<Class<Actor> > monsters;

	override void OnGameStart(Actor a)
	{
		ThinkerIterator ti = ThinkerIterator.Create("Actor");
			
		Actor t;
			
		while (t = Actor(ti.Next()))
		{
			if(CCards_Functions.IsLegalMonster(t) && t.health>0 && !CCards_Functions.HasMapSpecial(t.GetClass()) && !t.bBOSS)
			{
				if(monsters.Find(t.GetClass()) == monsters.Size())
				{
//					Console.Printf(t.GetClassNAme());
					monsters.Push(t.GetClass());

					if(t.default.health > maxhp)
					{
						maxhp = t.default.health;
					}
				}
			}
		}
	}
	
	override bool Condition()
	{	
		if(Level.Total_Secrets == 0)
		{
			return false;
		}
		return true;
	}

	override void PreGameStart(void)
	{
		playersecrets.Clear();

		if(playersecrets.Size() == 0)
		{
			for(int i; i<players.Size(); i++)
			{	
				playersecrets.Push(0);
			}
		}
		else
		{
			for(int i; i<playersecrets.Size(); i++)
			{
				playersecrets[i] == 0;
			}
		}
	}

	override void OnTick(actor a)
	{
		if((Level.Time % 35) != 0 || monsters.Size() == 0 || !isStackPrimary() || playersecrets.Size() == 0)
		{
			return;
		}
		
		if(players[a.PlayerNumber()].secretcount > playersecrets[a.PlayerNumber()])
		{
			for(int i; i<stackIndex+1; i++)
			{
				Class<Actor> monsterType;
				uInt r;
				uInt h = maxhp;

				while(!monsterType)
				{
					r = random(0, monsters.Size()-1);

					if(GetDefaultByType(monsters[r]).health < h)
					{
						h = h - 100;
						continue;
					}

					monsterType = monsters[r];
				}


				if(CCards_Functions.HasMapSpecial(monsterType))
				{
					continue;
				}
				
				int monradius = GetDefaultByType(monsterType).radius;
				int monheight = GetDefaultByType(monsterType).height;
				
				CCards_Actor_Safespawner spawner = CCards_Safespawner.New(monsterType.GetClassName(), 1, "CCards_Actor_TeleportFog", monradius, monheight, 128, 0);
				spawner.SetSpawnLocation(a);
				spawner.target = a;
				spawner.lastheard = a;
			}

			playersecrets[a.PlayerNumber()] += 1;
		}	
	}
}

Class CCard_MonsterToughen : Card
{
	override void Init()
	{
	effectMonsters = true;
	tier = 3;
	description = "All monsters have a lower flinch chance.";
	image = "CARD43";
	background = "CARB06";
	canStack = true;
	cardtag = TAG_MONSTER;
	}

	override void OnSpawn(Actor a)
	{
		a.painchance = Min(40, a.painchance / 2);

		if(a.painchance <= 10)
		{
			a.bNOPAIN = true;
		}
	}
}

Class CCard_MonsterPets : Card
{
	override void Init()
	{
	effectMonsters = true;
	tier = 3;
	image = "CARD64";
	background = "";
	canStack = true;
	cardtag = TAG_MONSTER;
	}

	uint mcount;
	uint rcount;
	bool disabled;
	Array<Class<Actor> > monsters;

	override bool Condition()
	{
		FillMonsterArray();

		if(monsters.Size() < 3)
		{
			return false;
		}

		return true;
	}

	override void PreGameStart()
	{
		if(!isStackPrimary())
		{
			disabled = true;
			return;
		}

		mcount = 0;
		rcount = 0;
		FillMonsterArray();
	}

	void FillMonsterArray()
	{
		Actor t;

		ThinkerIterator ti = ThinkerIterator.Create("Actor");

		while (t = Actor(ti.Next()))
		{
			if(!CCards_Functions.IsLegalMonster(t) 
			|| t.bBOSS 
			|| CCards_Functions.HasMapSpecial(t.GetClass())
			|| monsters.Find(t.GetClass()) != monsters.Size())
			{
				continue;
			}
			
			monsters.Push(t.GetClass());
		}
	}

	override void OnGameStart(Actor a)
	{
		if(disabled || rcount > 30 * (stackIndex + 1))
		{
			return;
		}

		if(mcount == 0)
		{
			Array<Class<Actor> > pets;

			for(int i; i<monsters.Size(); i++)
			{
				if(a.health > GetDefaultByType(monsters[i]).health / 2 && a.GetClass() != monsters[i])
				{
					pets.Push(monsters[i]);
				}
			}

			if(pets.Size() > 0)
			{
				Class<Actor> petclass = pets[random(0, pets.Size()-1)];
				SpawnPet(a, petclass);

				if(random(0, 20) == 0)
				{
					for(int i; i<5; i++)
					{
						petclass = pets[random(0, pets.Size()-1)];
						SpawnPet(a, petclass);
					}
				}
			}
			else
			{
				return;
			}
		}

		mcount++;

		if(mcount > 12 - Min(stackIndex, 12))
		{
			mcount = 0;
		}
	}

	void SpawnPet(Actor a, Class<Actor> petclass)
	{
		Actor pet = a.Spawn(petclass, a.pos);

		pet.bCANUSEWALLS = false;
		pet.bACTIVATEMCROSS = false;
		pet.bSOLID = false;
		pet.GiveInventory("CCards_Actor_MiniMonsterPowerup", 1);
		pet.bNOINFIGHTING = true;
		pet.A_ChangeVelocity(random(-4, 4), random(-4, 4), 0);
		pet.bAMBUSH = a.bAMBUSH;
		pet.bNOTARGET = true;

		CCards_Actor_PetOwnership po = CCards_Actor_PetOwnership(a.Spawn("CCards_Actor_PetOwnership"));
		po.AttachToOwner(pet);
		po.petowner = a;
		rcount++;
	}
}

class CCards_Actor_PetOwnership : Inventory
{
	Actor petowner;
	bool rendering;

	override void ModifyDamage (int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		if (petowner && damage > 0 && (source == petowner || inflictor == petowner))
		{
			newdamage = 0;
		}
	}

	override void Tick()
	{		
		if(!petowner)
		{
			Destroy();
			return;
		}

		if(petowner.health < 1)
		{
			Destroy();
			return;
		}

		if(owner && owner.health < 1)
		{
			if(petowner && owner.target)
			{
				petowner.target = owner.target;
				petowner.lastheard = owner.target;
				petowner.bNOINFIGHTING = true;
				petowner.bALWAYSFAST = true;
			}
			Destroy();
			return;
		}

		int dist = owner.Distance2D(petowner);

		if(owner && petowner)
		{
			if(dist > 512)
			{
				owner.Spawn("CCards_Actor_SmallTeleportFog", owner.pos);
				owner.SetOrigin(petowner.pos, false);
				owner.Spawn("CCards_Actor_SmallTeleportFog", owner.pos);
			}

			if((Level.Time % 5) == 0)
			{
				dist = owner.Distance3D(petowner);
				if(dist > 160 + petowner.radius)
				{	
					CCards_DropoffHelper.Create(owner, 10);
					double anglePitch;

					let diff = owner.Vec3To(petowner);
					anglePitch = -atan2 (diff.Z, diff.XY.Length());

					owner.Vel3DFromAngle(dist / 35, owner.AngleTo(petowner), anglePitch);
				}
			}

			if(Level.Time % (30) == 0)
			{
				if((!owner.CheckSightOrRange(800) || !petowner.CheckSightOrRange(800)))
				{
					rendering = true;
				}
				else
				{
					rendering = false;
				}
			}

			if(rendering)
			{
				RenderChain();
			}
		}

		Super.Tick();
	}

	void RenderChain()
	{
		Vector3 pointA = owner.pos + (0,0,owner.height/2);
		Vector3 pointB = petowner.pos + (0,0,petowner.height/2);


		let pointAB = pointB - pointA;
		
		let dist = pointAB.Length();
		double units = 5;

		units = Max(5, units + (dist / 20)); 
		
		pointAB /= dist == 0 ? 1 : dist;
		
		for (double i = 0; i < dist; i += units)
		{
			if(i < 10 || i > dist - 10)
			{
				continue;
			}
			let position = pointA + i * pointAB;
			Spawn("CCards_Actor_Petchain", position);
		}
	}
}


Class CCards_Actor_Petchain : CCards_Actor_FX
{
	Default
	{
		scale 0.25;
	}

	states
	{
		Spawn:
		C_F2 Y 2;
		stop;
	}
}

Class CCard_MonsterBreach : Card
{
	override void Init()
	{
	effectMonsters = true;
	tier = 1;
	image = "TNT1A0";
	background = "CARD68";
	canStack = false;
	cardtag = TAG_MONSTER;
	}

	override bool Condition()
	{
		uint counter;

		for(int i; i<level.lines.Size(); i++)
		{
			if(level.lines[i].special == 12)
			{
				counter++;

				if(counter == 4)
				{
					return true;
				}
			}
		}

		return false;
	}
	
	override void OnSpawn(Actor a)
	{
		a.GiveInventory("CCards_Actor_Breach", 1);
	}
}

Class CCards_Actor_Breach : CCards_Token
{
}


Class CCard_HealthSwap : Card
{
	override void Init()
	{
	effectWorld = true;
	tier = 4;
	image = "CARD73";
	background = "";
	canStack = false;
	cardtag = TAG_MONSTER;
	}

	override bool Condition()
	{
		return true;
	}

	uint timer;

	override void OnGameStart(Actor a)
	{
		timer = 0;
	}

	override void OnTick(Actor a)
	{
		if(timer < 101)
		{
			timer++;

			if(timer == 100)
			{
				Array<Actor> monsters;
				Array<Class<Actor> > monstershealths;
				Array<int> monstertotals;

				ThinkerIterator ti = ThinkerIterator.Create("CCards_MonsterThinker");
				CCards_MonsterThinker t;

				while (t = CCards_MonsterThinker(ti.Next()))
				{
					if(t.user && t.user.health > 0 && !t.user.bBOSS)
					{
						monsters.Push(t.user);

						if(monstershealths.Find(t.user.GetClass()) == monstershealths.Size())
						{
							monstershealths.Push(t.user.GetClass());
							monstertotals.Push(t.user.health);
							
						}
					}
				}

				while(monsters.Size()>0)
				{
					int r = random(0, monsters.Size() - 1);
					Actor mon = monsters[r];
					if(mon && mon.health > 0)
					{
						int newhealth = monstertotals[random(0, monstertotals.Size() - 1)];
						if(newhealth > mon.default.health)
						{
							mon.GiveInventory("CCards_Actor_MoreHealthEffects", 1);
						}
						
						mon.StartHealth = newhealth / G_SkillPropertyFloat(SKILLP_MonsterHealth);
						mon.health = newhealth;
						mon.SetInventory("CCards_Actor_MaxHealth", newhealth);
					}
					//Console.Printf(newhealth .. "");
					
					monsters.Delete(r);
				}
			}
		}
	}
}

class CCards_Actor_MoreHealthEffects : Inventory
{
	override void Tick()
	{
		if(!owner || owner.health < 1)
		{
			return;
		}

		if((GetAge() % 12) == 0 && !owner.CheckSightOrRange(128, true))
		{
			for(int i; i<(owner.radius / 30) + 1; i++)
			{
				owner.A_SpawnItemEx("CCards_Actor_CannibalismFedFX", random(-owner.radius + 8, owner.radius + 8), zofs: random(0, owner.height+8), angle: random(0,360));
			}
		}
	}
}

Class CCard_HotStart : Card
{
	override void Init()
	{
	effectPlayers = true;
	tier = 5;
	image = "CARD75";
	background = "";
	canStack = false;
	cardtag = TAG_EVENT;
	}

	override bool Condition()
	{
		return (game.global.collection.size() < 2);
	}

	override void OnGameStart(Actor a)
	{
		Array<Actor> monsters;
		CCards_MonsterThinker t;

		ThinkerIterator ti = ThinkerIterator.Create("CCards_MonsterThinker");

		while (t = CCards_MonsterThinker(ti.Next()))
		{
			if(t.user)
			{
				monsters.Push(t.user);
			}
		}

		CCards_Actor_HotStartSpawner h = CCards_Actor_HotStartSpawner(a.Spawn("CCards_Actor_HotStartSpawner", a.pos));

		h.monsters.Copy(monsters);
		h.target = a;
	}
}

class CCards_Actor_HotStartSpawner : Actor
{
	Default
	{
		+NOINTERACTION;
	}

	Actor monstertomove;
	Array<Actor> monsters;
	CCards_SafespawnerCallback spawnercallback;
	uint count;

	states
	{
		Spawn:
		TNT1 A 30;
		Goto Loopy;
		Loopy:
		TNT1 A 1
		{
			if(monsters.Size() == 0 || count >= 20 || !target)
			{
				Destroy();
				return;
			}

			if(!spawnercallback)
			{
				int r = random(0, monsters.Size()-1);
				monstertomove = monsters[r];
				monsters.Delete(r);

				if(!monstertomove || CCards_Functions.HasMapSpecial(monstertomove.GetClassName()))
				{
					return;
				}

				CCards_Actor_SafeSpawner s = CCards_Safespawner.New("CCards_Actor_HotStartSpawn", 1, "CCards_Actor_FastSpawnFire", monstertomove.radius, monstertomove.height, monstertomove.radius + 128, 4);
				
				if(!s)
				{
					//Console.Printf("piss!");
					return;
				}

				s.SetSpawnLocation(target);
				spawnercallback = new("CCards_SafespawnerCallback");
				s.spawnercallback = spawnercallback;
				return;
			}

			if(spawnercallback.spawnedactor)
			{
				if(monstertomove)
				{
					monstertomove.SetOrigin(spawnercallback.spawnedactor.pos, false);
					monstertomove.A_Face(target);
					monstertomove.A_StartSound("corruptioncards/hotstart");
					count++;
				}

				spawnercallback.spawnedactor.Destroy();
				spawnercallback.spawnedactor = null;
				spawnercallback.Destroy();
				//Console.Printf("spawn success");
				return;
			}
		}
		loop;
	}
}

Class CCards_Actor_HotStartSpawn : CCards_Boss_RomeroSpawnLocation {}
