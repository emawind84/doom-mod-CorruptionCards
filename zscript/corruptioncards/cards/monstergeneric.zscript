// Generic cards usable by ANY monster

Class CCard_AdditionalMonster : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	description = "All " .. GetMonsterName() .. " in the level are increased by one.";
	background = "CARB01";
	canStack = true;
	}
	
	override bool Condition()
	{
		if(monsterFigure.bBOSS)
		{
			return false;
		}
		
		return true;
	}

	uint count;

	override void PreGameStart()
	{
		count = 0;
	}

	override void OnGameStart(Actor a)
	{
		if(CCards_Functions.HasMapSpecial(monsterType) || count >= 100)
		{
			return;
		}

		count++;

		Actor clone = a.Spawn(a.GetClassName(), a.pos);
		if(clone)
		{
			clone.angle = a.angle + random(0,360);
			clone.bAMBUSH = a.bAMBUSH;
			
			if(clone.bSOLID)
			{
				clone.GiveInventory("CCards_Actor_SolidHelper", 1);
			}
		}
	}
}

Class CCard_RespawningMonster : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	description = GetMonsterName() .. " respawns after death.";
	background = "CARB04";
	canStack = false;
	priority = 1000;
	AddTag("resurrection");
	}
	
	bool isSpecialMap;
	
	override bool Condition()
	{		
		if(game.G_SkillPropertyInt(SKILLP_RESPAWN))
		{
			return false;
		}
		
		if(monsterFigure.default.health < 150 || monsterFigure.bBOSS || CCards_Functions.HasMapSpecial(monsterType))
		{
			return false;
		}

		return true;
	}

	override void OnGameStart(Actor a)
	{
		ThinkerIterator ti = ThinkerIterator.Create("CCards_RespawnManager");
				
		CCards_RespawnManager r;
			
		r = CCards_RespawnManager(ti.Next());

		if(!r)
		{
			r = CCards_RespawnManager(new ("CCards_RespawnManager"));
		}

		if((a.bBOSS || a.bBOSSDEATH) && isSpecialMap)
		{
			return;
		}

		r.AddMonster(a);
	}
}

Class CCards_RespawnManager : Thinker
{
	Array<CCards_MonsterRespawner> monsters;

	void AddMonster (Actor a)
	{
		if(CCards_Functions.HasMapSpecial(a.GetClass()))
		{
			return;
		}

		CCards_MonsterRespawner m = CCards_MonsterRespawner(new ("CCards_MonsterRespawner"));
		m.monster = a;
		m.pos = a.pos;
		m.monstertype = a.GetClass();
		monsters.Push(m);
	}

	override void Tick()
	{
		if((Level.Time % 35) != 0)
		{
			return;
		}

		for(int i; i<monsters.Size(); i++)
		{
			if(monsters[i].monster && monsters[i].monster.CountInv("CCards_Actor_HasRespawned") > 0)
			{
				continue;
			}

			if(monsters[i].monster && monsters[i].monster.health < 1 && !monsters[i].isdead)
			{
				monsters[i].isDead = true;
				monsters[i].timer = (4 * ((random(10, 60)) + (monsters[i].monster.default.health / 50)));
				continue;
			}

			if(monsters[i].isdead)
			{
				monsters[i].timer--;

				//Console.Printf("" .. monsters[i].timer);
				if(monsters[i].timer<1)
				{
					//Console.Printf("time to respawn!");
					if(monsters[i].monster)
					{
						if(monsters[i].monster.health<1)
						{
							monsters[i].monster.A_SetScale(monsters[i].monster.default.scale.x, monsters[i].monster.default.scale.y);
							//monsters[i].monster.A_SetTranslation(monsters[i].monster.default.Translation);
							monsters[i].monster.A_Respawn(RSF_KEEPTARGET|RSF_FOG);
							monsters[i].monster.GiveInventory("CCards_Actor_HasRespawned", 1);
							if(monsters[i].monster.bCOUNTKILL)
							{
								monsters[i].monster.ClearCounters();
							}
							continue;
						}
						else
						{
							monsters[i].isdead = false;
						}
					}
					
					if(!monsters[i].monster)
					{
						Actor a = Actor.Spawn(monsters[i].monstertype, monsters[i].pos);

						if(a)
						{
							a.Spawn("TeleportFog", a.pos);
							a.angle = random(0,360);
							monsters[i].monster = a;
							monsters[i].isdead = false;
							a.GiveInventory("CCards_Actor_ForcedRespawn", 1);
							a.GiveInventory("CCards_Actor_HasRespawned", 1);
							if(monsters[i].monster.bCOUNTKILL)
							{
								monsters[i].monster.ClearCounters();
							}
						}
					}
				}
			}
		}
	}
}

Class CCards_MonsterRespawner
{
	Actor monster;
	Class<Actor> monstertype;
	Vector3 pos;
	uint timer;
	bool isdead;
}

Class CCards_Actor_HasRespawned : Inventory {}

Class CCard_MonsterGang : GenericCard
{
	mixin WorldEvent;

	CCards_Actor_SafeSpawner spawner;
	bool isSpawning;
	bool finished;
	Vector3 pos;
	
	override void Init()
	{
	Super.Init();
	effectWorld = true;
	description = "A gang of " .. GetMonsterName() .. " may appear.";
	background = "CARB17";
	canStack = true;
	}
	
	override bool Condition()
	{	
		if(monsterFigure.bBOSS)
		{
			return false;
		}
		return true;
	}
	
	override void OnGameStart(actor a)
	{
		SetEventTotals();

		isSpawning = false;
		finished = false;
		
		if(CCards_Functions.HasMapSpecial(monsterType))
		{
			finished = true;
		}
	}
	
	override void OnTick(actor a)
	{
		if(finished)
		{
			return;
		}
		
		if(EventTrigger() && !isSpawning)
		{
			spawner = CCards_Safespawner.New("", 1, "", GetDefaultByType(monsterType).radius, GetDefaultByType(monsterType).height, 0, 0);
			isSpawning = true;
		}
		
		if(isSpawning)
		{
			if(spawner)
			{
				pos = spawner.pos;
			}
			else
			{
				CCards_Actor_GangPortal p = CCards_Actor_GangPortal(Actor.Spawn("CCards_Actor_GangPortal", pos));
				CCards_Functions.CardAlert("\ciA gang of monsters is spawning!", "corruptioncards/cube");
				finished = true;
				
				p.monster = monsterType;

				uint amount = 25;
				
				amount -= (GetDefaultByType(monsterType).health / 40);

				p.spawncount = Max(5, amount);
				//p.A_LogInt(p.spawncount);
			}
		}
	}
}

class CCards_Actor_GangPortal : Actor
{
	Default
	{
		-SOLID;
		+NOINTERACTION;
		+BRIGHT
		scale 1.5;
	}
	
	int spawncount;
	Class<Actor> monster;
	Actor newmon;
	
	states
	{
		Spawn:
		TNT1 A 1;
		TNT1 A 0
		{			
			target = CCards_Functions.RandomPlayer();
		}		
		Portal:
		TNT1 A 0
		{
			
			Actor clone = Spawn(monster, pos);//A_SpawnItemEx(monster);
			if(clone)
			{	
				if(target)
				{
				clone.LastHeard = target;
				clone.target = target;
				}
				if(clone.bSOLID)
				{
					clone.GiveInventory("CCards_Actor_SolidHelper", 1);
				}
				
				spawncount--;
				
				if(spawncount == 0)
				{
				SetStateLabel("Death");
				}
				//A_AlertMonsters(0, 0);
				
				A_StartSound("misc/teleport");
			}
		}
		C_F0 JKLMLK 4;
		loop;
		Death:
		C_F0 JKJKLMNOPQRS 4;
		stop;
	}
}

Class CCard_ChildMonster : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	description = GetMonsterName() .. " has a small companion.";
	background = "CARB22";
	canStack = true;
	}
	
	uint count;

	override void PreGameStart()
	{
		count = 0;
	}

	override void OnGameStart(Actor a)
	{
		if(CCards_Functions.HasMapSpecial(monsterType) ||  count >= 100)
		{
			return;
		}

		count++;

		Actor clone = a.Spawn(a.GetClassName(), a.pos);
		
		if(clone)
		{
			clone.A_GiveInventory("CCards_Actor_MiniMonsterPowerup", 1);
			//clone.bTHRUSPECIES = true;
			
			clone.angle = a.angle + random(0,360);
			clone.bAMBUSH = a.bAMBUSH;
			
			if(clone.bSOLID)
			{
				clone.GiveInventory("CCards_Actor_SolidHelper", 1);
			}
		}
	}

}

Class CCards_Actor_MiniMonsterPowerup : PowerDamage
{
	Default
	{
		Damagefactor "normal", 0.75;
	}

	bool isdead;

	override void OwnerDied ()
	{
		isdead = true;
		//Destroy ();
	}

	override void Tick ()
	{
		if(!owner)
		{
			return;
		}
	}

	override void AttachToOwner(Actor a)
	{
		int newhp = a.default.health / 2;
		a.StartHealth = newhp / G_SkillPropertyFloat(SKILLP_MonsterHealth);
		a.health = newhp;
		a.SetInventory("CCards_Actor_MaxHealth", a.health);
		a.GiveInventory("CCards_Actor_HalfProjectileZOff", 1);
		Super.AttachToOwner(a);

	}

	override void DoEffect()
	{	
		if(!owner)
		{
			return;
		}

		if(owner.health>0 && isdead)
		{
			isdead = false;
			InitEffect();
		}

		Owner.A_SoundPitch(CHAN_VOICE, 1.15);

		float miniscale = 0.60;

		if(owner.scale.x != owner.default.scale.x * miniscale)
		{
			owner.A_SetScale(owner.default.scale.x * miniscale, owner.default.scale.y * miniscale);
		}

		if(owner.radius != owner.default.radius * miniscale)
		{
			owner.A_SetSize(owner.default.radius * miniscale, owner.default.height * miniscale);
		}
	}
}

Class CCard_MonsterAssassin : GenericCard
{
	mixin WorldEvent;

	CCards_Actor_SafeSpawner spawner;
	bool isSpawning;
	bool finished;
	Vector3 pos;

	int power;
	
	override void Init()
	{
	Super.Init();
	useSpecies = false;
	effectPlayers = true;
	description = "A " .. GetMonsterName() .. " will try to assassinate you.";
	background = "CARB23";
	canStack = true;
	cardtag = TAG_EVENT;
	}
	
	override bool Condition()
	{	
		if(monsterFigure.health < 200)
		{
			return false;
		}
		return true;
	}
	
	override void OnGameStart(actor a)
	{
		SetEventTotals();
		isSpawning = false;
		finished = false;
	}
	
	override void OnTick(actor a)
	{
		if(finished)
		{
			return;
		}
		
		if(CCards_Functions.HasMapSpecial(monsterType))
		{
			finished = true;
			return;
		}
		
		if(isSpawning)
		{
			ThinkerIterator ti = ThinkerIterator.Create("CCards_AssassinSpawn");
				
			CCards_AssassinSpawn t;
			
			while (t = CCards_AssassinSpawn(ti.Next()))
			{
				if(t.target)
				{
				t.target.health = t.target.health + ((t.target.health / 5) * Min(power, 5));
				t.target.GiveInventory("CCards_Actor_AssassinBuff", 1);
				//t.target.GiveInventory("CCards_Actor_TeleporterBuff", 1);
				t.target.SetTag(t.target.GetTag() .. " \cg(ASSASSIN!)");
				t.target.seesound = "";
				t.target.activesound = "";
				t.target.target = a;
				t.target.lastheard = a;
				t.target.bALWAYSFAST = true;
				t.target.bNOBLOCKMONST = true;
				t.target.bNOTARGETSWITCH = true;
				t.target.bNOINFIGHTING = true;
				finished = true;
				power++;
				break;
				}
			}

			return;
		}
		
		if(EventTrigger())
		{
			spawner = CCards_Safespawner.New(monsterType.GetClassName(), 1, "CCards_AssassinSpawn", GetDefaultByType(monsterType).radius, GetDefaultByType(monsterType).height, 128, 0);
			spawner.SetSpawnLocation(a);
			isSpawning = true;
		}
	}
}

class CCards_Actor_AssassinBuff : PowerDamage
{
	Default
	{
		DamageFactor "Normal", 1.8;
		powerup.duration -99999;
	}
	
	override void DetachFromOwner()
	{
		effecttics = 0;
		if(owner && owner.health < 1)
		{
			CCards_Functions.CardAlert("\crAn assassin was killed!", "corruptioncards/assassindeath");
		}
		Super.DetachFromOwner();
	}
}

class CCards_AssassinSpawn : Actor
{
	Default
	{
	+NOINTERACTION;
	+MISSILE;
	height 1;
	radius 1;
	renderstyle "style_none";
	}
	
	states
	{
	Spawn:
	PLAY A 35;
	stop;
	}
}

Class CCard_MonsterThief : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	description = GetMonsterName() .. " will steal items off the ground.";
	background = "CARB25";
	canStack = false;
	}

	override void SetTier()
	{
		Super.SetTier();

		tier = Min(tier, 3);
	}

	Array<Inventory> grounditems;
	
	override bool Condition()
	{
		if(monsterFigure.bBOSS)
		{
			return false;
		}
	
		return true;
	}
	
	override void OnGameStart(Actor a)
	{
		if(grounditems.Size() == 0)
		{
			ThinkerIterator ti = ThinkerIterator.Create("Inventory");
			Inventory inv;

			while (inv = Inventory(ti.Next()))
			{
				if(inv.owner || CCards_Functions.ActorIsKey(inv) || inv.tid>0 || inv.special)
				{
					continue;
				}

				grounditems.Push(inv);
			}
		}

		StealItem(a, 512.0);
	}
	
	override void OnTick(Actor a)
	{
		if(a.health<1)
		{
			return;
		}
		if((Level.Time % 35*5) == 0)
		{
			StealItem(a, 100.0);
		}
	}
	
	void StealItem (Actor a, Float radius)
	{
		if(a.CountInv("CCards_Actor_StolenItem")>0)
		{
			return;
		}

		for(int i = 0; i<grounditems.Size(); i++)
		{
			Inventory inv = grounditems[i];

			if(!inv || inv.owner)
			{
				grounditems.Delete(i);
				continue;
			}

			if(a.Distance2D(inv) < radius && inv.CountInv("CCards_Actor_StolenItem")==0 && !a.bDORMANT)
			{
				CCards_MonsterTheft tf = new("CCards_MonsterTheft");
				tf.monster = a;
				tf.item = inv;
				a.GiveInventory("CCards_Actor_StolenItem", 1);
				inv.GiveInventory("CCards_Actor_StolenItem", 1);
				inv.bTHRUACTORS = true;
				
				return;
			}
		}
	}
}

Class CCards_Actor_StolenItem : Inventory
{
	Default
	{
	inventory.maxamount 1;
	}
}

Class CCards_MonsterTheft : Thinker
{
	Actor item;
	Actor monster;
	
	override void Tick()
	{
		if(!item || !monster || monster.health < 1)
		{
			if(item)
			{
				item.TakeInventory("CCards_Actor_StolenItem", 1);
				item.A_ChangeVelocity(0, 0, 7, CVF_REPLACE);
				item.bTHRUACTORS = false;
			}
			
			if(monster)
			{
				monster.TakeInventory("CCards_Actor_StolenItem", 1);
			}
			
			Destroy();
			return;
		}
		
		if(item.warp(monster, -6.0, 0, (monster.height / 4) * 3, 0, WARPF_COPYINTERPOLATION))
		{
			return;
		}
		
		if(item)
		{
			item.TakeInventory("CCards_Actor_StolenItem", 1);
			item.bTHRUACTORS = false;
		}
		
		if(monster)
		{
			monster.TakeInventory("CCards_Actor_StolenItem", 1);
		}
		
		Destroy();
	}
}


Class CCard_MonsterVehicle : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	description = GetMonsterName() .. " can carry other monsters.";
	background = "CARD42";
	canStack = false;
	}

	override bool Condition()
	{
		if(monsterFigure.health <= 60)
		{
			return false;
		}
		return true;
	}
	
	override void OnSpawn(Actor a)
	{
		if(a.CountInv("CCards_Actor_Saddle")>0)
		{
			return;
		}

		a.GiveInventory("CCards_Actor_Saddle", 1);
	}
}

class CCards_Actor_Saddle : Inventory
{
	uint animtimer;

	Actor TryGrab (double r, bool nosight)
	{
		if(!nosight && owner.CheckSightOrRange(1000, true))
		{
			return null;
		}

		if(owner.bDORMANT || owner.bFRIENDLY)
		{
			return null;
		}

		BlockThingsIterator bi = BlockThingsIterator.Create(owner, r);

		Actor mo;

		while(bi.Next())
		{
			mo = bi.thing;
			//Console.Printf("" .. bi.thing.GetclassName());
			if(mo && owner && mo.default.speed > 0 && mo.health>0 && mo.CountInv("CCards_Actor_IsRiding") == 0 && mo.bIsMonster && mo != owner && !(mo is "Inventory"))
			{
				CCards_Actor_Saddle s = CCards_Actor_Saddle(mo.FindInventory("CCards_Actor_Saddle"));

				if(s && s.rider)
				{
					continue;
				}

				if(mo.GetClassName() == owner.GetClassName())
				{
					continue;
				}

				if(nosight)
				{
					return mo;	
				}
				
				if(owner.CheckSight(mo))
				{
					return mo;
				}

				continue;
			}
		}

		return null;
	}

	Actor rider;

	void DropRider(bool died)
	{
		if(rider)
		{
			//Console.Printf("dropped");
			rider.TakeInventory("CCards_Actor_IsRiding", 1);

			rider.bNOPAIN = rider.default.bNOPAIN;
			rider.bNOGRAVITY = rider.default.bNOGRAVITY;
			rider.bFLOAT = rider.default.bFLOAT;
			rider.bDROPOFF = rider.default.bDROPOFF;
			rider.floatspeed = rider.default.floatspeed;
			rider.speed = rider.default.speed;
			rider.MinMissileChance = rider.default.MinMissileChance;
			
			if(rider.default.bSOLID && !died)
			{
				rider.bSOLID = true;
				rider.GiveInventory("CCards_Actor_SolidHelper_NoMove", 1);
			}

			rider.A_ChangeVelocity(0, 0, 5, CVF_RELATIVE);
			//rider.A_SetSize(rider.default.height, rider.default.radius);
			rider = null;
		}
	}

	override void OnDestroy()
	{
		DropRider(false);
	}

	override void Tick()
	{
		if(rider)
		{
			if(rider.target == owner)
			{
				rider.A_ClearTarget();
			}

			if(owner.target == rider)
			{
				if(owner.lastheard)
				{
					owner.target = owner.lastheard;
				}
				else
				{
					owner.A_ClearTarget();
				}
			}

			rider.MinMissileChance = 40;
			rider.bSOLID = false;
			rider.bDROPOFF = true;
			rider.bNOGRAVITY = true;
			rider.bFLOAT = true;
			rider.bNOPAIN = true;
			rider.bNOPAIN = true;
			rider.floatspeed = 0;
			rider.speed = 0;

			if(!rider.Warp(owner, 0, 0, owner.height, 0, WARPF_TESTONLY) || rider.health < 1 || owner.health < 1)
			{
				DropRider((rider.health < 1));
			}
			else
			{
				rider.A_ScaleVelocity(0.7);
				if(animtimer < 25)
				{
					Vector3 destination = owner.pos + (0, 0, owner.height);
					rider.SetOrigin(CCards_Functions.Vec3Lerp(rider.pos, destination, animtimer * 0.03), true);
					animtimer++;
				}
				else
				{
					rider.Warp(owner, 0, 0, owner.height, 0, WARPF_COPYINTERPOLATION|WARPF_USECALLERANGLE);
				}
			}
		}
		
		if(owner.health < 1)
		{
			if(rider)
			{
				DropRider(false);
			}
			return;
		}

		if((Level.Time % 35*3) == 0 && !rider)
		{
			double rad = 40.0;
			bool thruwalls = false;

			if(CCards_Functions.GetGameTime() < 35*5)
			{
				rad = 300.0;
				thruwalls = true;
			}

			rider = TryGrab(radius + rad, thruwalls);

			if(rider)
			{
				if(rider.Warp(owner, 0, 0, owner.height, 0, WARPF_TESTONLY) && 
				!(rider.bBOSS && !owner.bBOSS) && 
				!rider.bFRIENDLY &&
				owner.bSHOOTABLE && 
				!rider.bNOGRAVITY && 
				!CCards_Functions.HasMapSpecial(rider.GetClass()))
				{
					rider.GiveInventory("CCards_Actor_IsRiding", 1);
					rider.TakeInventory("CCards_Actor_SentryActivator", 1);
					animtimer = 0;
					//rider.Spawn("CCards_Actor_Smoke", rider.pos);		
					//rider.Spawn("CCards_Actor_Smoke", (owner.pos.x, owner.pos.y, owner.pos.z + height));
				}
				else
				{
					rider = null;
				}
			}
		}
	}
}

class CCards_Actor_IsRiding : Inventory {}

Class CCard_MonsterHunter : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	description = GetMonsterName() .. " are always focused on players.";
	background = "CARB31";
	canStack = false;
	}
	
	override bool Condition()
	{
		return true;
	}
	
	override void OnTick(Actor a)
	{
		if((Level.Time % 35) != 0 || a.target)
		{
			return;
		}

		actor p = CCards_Functions.RandomPlayer();

		if(p && p.health>0)
		{
			if(a.bAMBUSH)
			{
				a.bAMBUSH = false;
			}
			a.lastheard = p;
			a.target = p;
			a.bNOINFIGHTING = true;

			// This compatflag would alert *all* monsters
			if(!CVar.GetCvar("compat_soundtarget", null).GetBool())
			{
				a.A_AlertMonsters(4, 0);
			}
		}
	}
}

Class CCard_MonsterShockwaves : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	background = "CARB49";
	canStack = false;
	}
	
	override bool Condition()
	{
		tier = 1;
		if(monsterFigure.bBOSS)
		{
			return false;
		}
		
		return true;
	}

	override void OnDeath(Actor a)
	{
		CCards_Actor_Shockwave s = CCards_Actor_Shockwave(a.Spawn("CCards_Actor_Shockwave", a.pos + (0,0,(a.default.height /2 - 2))));
		if(s)
		{
			s.addstrength = (a.default.health / 30);
		}
	}
}

Class CCards_Actor_Shockwave : CCards_Actor_FX
{
	int rad;
	int addstrength;
	bool firstshock;

	States
	{
		Spawn:
		TNT1 A 5;
		TNT1 A 5
		{
			Spawn("CCards_Actor_ShockwaveFX", pos);
			A_StartSound("corruptioncards/shockwave", CHAN_7);
		}
		TNT1 A 0 A_Quake(2, 5, 0, 200, "");
		TNT1 AAA 3
		{
			rad++;

			ThinkerIterator ti = ThinkerIterator.Create("Actor");
					
			Actor t;
				
			while (t = Actor(ti.Next()))
			{
				Inventory inv = Inventory(t);

				if(t.bSHOOTABLE || ((inv && !inv.owner) && !(Actor.GetReplacee(t.GetClass()) is "Key")))
				{
					if(CCards_Functions.HasMapSpecial(t.GetClass()))
					{
						continue;
					}

					float dist = t.Distance3D(self);
					if((dist) < 135 * rad &&
					t.pos.z < pos.z + 80 &&
					t.pos.z > pos.z - 80
					)
					{
						Vector3 v = t.vel;
						int strength = (10 + addstrength) - (dist / 100);

						if(t.player)
						{
							strength = strength * 0.85;
						}

						if(t.bSHOOTABLE && !firstshock)
						{
							CCards_DropoffHelper.Create(t, 35);
						}

						if(t is "Inventory")
						{
							t.bSLIDESONWALLS = true;
							strength = strength * 2.0;
						}
						
						t.Vel3DFromAngle(strength, self.AngleTo(t), 0);
						t.vel += v;
					}
				}
			}

			firstshock = true;
		}
		TNT1 A 60;
		stop;
	}
}

Class CCard_MonsterFeignDeath : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	background = "CARB55";
	canStack = false;
	AddTag("resurrection");
	}
	
	override bool Condition()
	{
		if(monsterFigure.bBOSS || !monsterFigure.FindState("Raise", true) || monsterfigure is "PainElemental")
		{
			return false;
		}
		
		return true;
	}

	override void OnSpawn(Actor a)
	{
		if(random(0, 5) == 0 && a.tid == 0 && !a.bBOSS && a.FindState("Raise", true))
		{
			a.GiveInventory("CCards_Actor_FeignDeath", 1);
			a.bNOICEDEATH = true;
		}
	}
}

class CCards_Actor_FeignDeath : Inventory
{
	override void AttachToOwner(Actor other)
	{
		Super.AttachToOwner(other);

		if(other.CountInv("CCards_Actor_AssassinBuff") > 0)
		{
			return;
		}

		if(other.health > 0)
		{
			uint newhp = random(1, other.health / 4);
			other.SetInventory("CCards_Actor_MaxHealth", newhp);
			other.health = newhp;
			return;
		}
	}

	uint timer;
	bool hasdied;

	override void Tick()
	{
		if(!owner)
		{
			Destroy();
			return;
		}

		if(owner.health < 1)
		{
			if(!hasdied)
			{
				hasdied = true;
				timer = random(35, 35*10);
			}

			if(timer>0)
			{
				timer--;
			}
			
		}

		if(owner.health > 0 && hasdied)
		{
			Destroy();
			return;
		}

		if(hasdied && timer < 1)
		{
			RaiseActor(owner);
		}

		Super.Tick();
	}
}

Class CCard_MonsterSentry : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	background = "CARB56";
	canStack = false;
	}
	
	override bool Condition()
	{
		if(monsterFigure.bBOSS || !monsterFigure.FindState("Raise", true) || 
		monsterFigure.GetClassName() == "PainElemental" || 
		monsterFigure.GetClassName() == "Demon" ||
		monsterFigure.GetClassName() == "Spectre")
		{
			return false;
		}
		
		return true;
	}

	int count;

	override void OnGameStart(Actor a)
	{
		count -= random(0, 1);

		if(count < 1 && a.tid == 0 && !a.bBOSS && a.FindState("Raise", true))
		{
			a.GiveInventory("CCards_Actor_SentryActivator", 1);
			a.bNOICEDEATH = true;
			count = 5;
		}
	}
}

class CCards_Actor_SentryDamageNerf : PowerDamage
{
	Default
	{
		Powerup.Duration -3;
		Damagefactor "normal", 0.6;
	}
}

class CCards_Actor_SentryActivator : Inventory
{
	override void AttachToOwner(Actor other)
	{
		Super.AttachToOwner(other);
	}

	bool issentry;
	bool hasdied;
	int timer;
	Vector2 anchorpos;

	override void Tick()
	{
		if(!owner)
		{
			Destroy();
			return;
		}

		if(owner.health < 1)
		{
			if(!hasdied)
			{
				hasdied = true;
				timer = random(35, 35*3) + ((owner.default.health / 200) * 35);
			}

			if(timer>0)
			{
				timer--;
			}
		}

		if(hasdied && timer < 1)
		{
			if(RaiseActor(owner))
			{
				owner.bNOICEDEATH = true;
				if(owner.default.bCOUNTKILL)
				{
					owner.A_ChangeCountFlags(0, 0, 0);
				}
				owner.GiveInventory("CCards_Actor_SentryDamageNerf", 1);
				hasdied = false;
			}
		}

		if(!issentry)
		{
			if(owner.target && owner.CheckSight(owner.target, SF_IGNOREVISIBILITY))
			{
				anchorpos = (owner.pos.x, owner.pos.y);
				issentry = true;
				for(int i; i<4; i++)
				{
					owner.A_SpawnItemEx("CCards_Actor_SentryProp", 16 + owner.radius / 2, angle: i * 90, flags:SXF_NOCHECKPOSITION);
				}
				
			}
		}
		else
		{
			owner.bSOLID = false;
			owner.speed = 0;
			owner.SetOrigin((anchorpos.x, anchorpos.y, owner.pos.z), true);
		}

		Super.Tick();
	}
}

class CCards_Actor_SentryProp : CCards_Actor_FX
{
	Default
	{
		+MISSILE;
		+FLOATBOB;
		FloatBobStrength 0.25;
		Scale 0.75;
	}

	states
	{
		Spawn:
		C_F3 AB 3
		{
			if(!target || target.CountInv("CCards_Actor_SentryActivator") == 0)
			{
				Destroy();
				return;
			}

			bBRIGHT = (target.health < 1);
			SetOrigin((pos.x, pos.y, target.pos.z + 8 + (target.height / 32)), true);
		}
		loop;
	}
}

Class CCard_MonsterLastWord : GenericCard
{
	override void Init()
	{
	Super.Init();
	effectMonsters = true;
	tier = 0;
	background = "CARB57";
	description = "";
	canStack = true;
	usespecies = true;
	}

	uint calculateTier(int health)
	{
		if(health > 0)
		{
			return max(1, min(5, health / 120));
		}

		return 1;
	}

	Class<Actor> projectile;

	override void OnDeath(Actor a)
	{
		if(!projectile)
		{
			return;
		}

		let l = CCards_Actor_LastWordPortal(a.Spawn("CCards_Actor_LastWordPortal", a.pos + (0,0,a.default.height / 2)));

		if(!l)
		{
			return;
		}
		
		l.projectile = projectile;
		l.target = a;
		if(a.target)
		{
			l.tracer = a.target;
		}
		else
		{
			l.tracer = l;
		}
	}

	override bool Condition()
	{

		if(!projectile)
		{
			FindProjectile();
		}

		if(projectile)
		{
			if(monsterfigure.health > 500)
			{
				return false;
			}
			return true;
		}
		
		// Defaults for debug viewing
		projectile = "DoomImpBall";
		tier = 1;
		description = GetMonsterName() .. " fire a Imp projectile on death.";
		return false;
	}

	void FindProjectile()
	{
		if(projectile)
		{
			return;
		}
		Array<CCards_Monster> users;

		for(int i; i<game.global.projectileUsers.Size(); i++)
		{
			CCards_Monster pi = game.global.projectileUsers[i];

			users.Push(pi);
		}

		while(users.Size()>0)
		{
			int r = game.global.RandomNumber(0, users.size()-1);

			if(GetDefaultByType(users[r].projectile).radius > 16 || GetDefaultByType(users[r].projectile).speed == 0)
			{
				users.Delete(r);
			}
			else
			{
				projectile = users[r].projectile;
				String monstername = GetDefaultByType(users[r].monsterClass).GetTag();
				tier = calculateTier(GetDefaultByType(users[r].monsterClass).health);
				SetDescription(monstername);
				return;
			}
		}		
	}

	virtual void SetDescription(String name)
	{
		description = GetMonsterName() .. " fire a " .. name .. " projectile on death.";
	}
}

Class CCards_Actor_LastWordPortal : Actor
{
	Default
	{
		+MISSILE;
		-SOLID;
		//+NOBLOCKMAP;
		+THRUACTORS;
		+NOGRAVITY;
		+ROLLSPRITE;
		+BRIGHT;
		renderstyle "STYLE_Translucent";
		alpha 0.0;
		scale 1.2;
		height 2;
		radius 2;
		speed 8;
		Translation "CCards_LastWord";
	}

	Class<Actor> projectile;

	states
	{
		Spawn:
		TNT1 A 8;
		TNT1 A 0
		{
			if(!projectile)
			{
				projectile = "DoomImpBall";
			}
			A_FaceTracer();
		}
		TNT1 A 0 A_PlaySound("corruptioncards/lastword", CHAN_VOICE);
		C_F2 ZZZZZZZZZZZZZZZZZZZZZZZ 1 
		{
			roll += 10.0;
			A_FadeIn(0.055);
			A_SetScale(scale.x - 0.05, scale.x - 0.05);
			if(projectile)
			{
				FLineTraceData d;
				if(LineTrace (0, GetDefaultByType(projectile).radius, 0, TRF_ALLACTORS, data:d))
				{
					if(d.HitActor)
					{
						if(!d.HitActor.player && (d.HitActor.bSOLID || d.HitActor.bSHOOTABLE))
						{
							SetOrigin(pos + (0,0,32), false);
						}
					}
				}
			}
		}
		TNT1 A 0
		{
			A_StopSound(CHAN_VOICE);
			A_PlaySound("corruptioncards/shockwave");
			roll = 0;
			A_SetScale(0.3, 0.3);

			A_FaceTracer();	

			if(tracer)
			{
				FireProjectile();
			}
			//SpawnProjectile(projectile);
		}
		C_F0 VWXYZ 2;
		stop;
	}

	virtual Actor FireProjectile()
	{
		Actor f = Actor(A_SpawnProjectile(projectile, 0, 0, 0, ptr:AAPTR_TRACER));

		if(f)
		{
			//f.GiveInventory("CCards_Token_NotProjectileThrower", 1); // This line crashes?
			CCards_Token_NotProjectileThrower t = CCards_Token_NotProjectileThrower(Spawn("CCards_Token_NotProjectileThrower"));
			t.AttachToOwner(f);
			f.target = target;
			if(Abs(f.Vel.x) == 0 && Abs(f.Vel.y) == 0)
			{
				let diff = Vec3To(tracer);
				float anglePitch = -atan2 (diff.Z, diff.XY.Length());
				f.Vel3DFromAngle(10, angle, anglePitch);
				f.A_Face(tracer);
			}

			return f;
		}

		return null;
	}
}

Class CCard_MonsterTreachery : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	background = "CARB59";
	canStack = false;
	}
	
	override bool Condition()
	{
		if(monsterFigure.bBOSS || monsterfigure is "PainElemental" || monsterfigure.health < 60)
		{
			return false;
		}

		if(Ccards_Functions.FindCardByName("CCard_DisableInfight"))
		{
			return false;
		}
		
		return true;
	}

	override void OnSpawn(Actor a)
	{
		a.GiveInventory("CCards_Actor_Treachery", 1);
	}
}

class CCards_Actor_Treachery : Inventory 
{
	uint timer;

	override void Tick()
	{
		if(owner && owner.health > 0 && (Level.Time % timer) == 0)
		{
			if(!owner.target)
			{
				Super.Tick();
				return;
			}

			ThinkerIterator ti = ThinkerIterator.Create("Actor");
			Actor a;

			while(a = Actor(ti.Next()))
			{
				if(a.Distance2D(owner) > 512)
				{
					continue;
				}

				if(a.bISMONSTER && a.health > 0 && a.health <= a.SpawnHealth() / 4 && !a.bNOTARGET)
				{
					if(a.species != "None" && owner.species != "None")
					{
						if(a.species == owner.species)
						{
							continue;
						}
					}

					if(owner.GetClass() == a.GetClass())
					{
						continue;
					}
					
					owner.LastEnemy = owner.target;
					owner.target = a;
					timer = random(5, 10) * 35;
					break;
					
				}
			}
		}
		Super.Tick();
	}

	override void PostBeginPlay()
	{
		timer = random(5, 10) * 35;
	}

	void Trigger()
	{
		if(!owner || owner.health < 1)
		{
			return;
		}

		CCards_Actor_AngerBuff a;
		
		while(!a)
		{
			owner.GiveInventory("CCards_Actor_AngerBuff", 1);
			a = CCards_Actor_AngerBuff(owner.FindInventory("CCards_Actor_AngerBuff"));
		}

		if(a.powerlevel < 4)
		{
			a.powerlevel = 4;
			a.showtics = 3;
			owner.A_StartSound("corruptioncards/anger", CHAN_ITEM);
		}
		
		if(owner.health < CCards_Functions.GetMaxHealth(owner))
		{
			owner.health = min(CCards_Functions.GetMaxHealth(owner), owner.health + (CCards_Functions.GetMaxHealth(owner) / 4));
			owner.Spawn("CCards_Actor_HealFXSpawner", owner.pos);
		}
	}
}

Class CCard_MonsterIcyTread : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	background = "CARB63";
	canStack = false;
	}
	
	override bool Condition()
	{
		if(monsterFigure.bNOGRAVITY || monsterFigure.bFLOAT || CCards_Functions.HasMapSpecial(monsterType))
		{
			return false;
		}
		
		return true;
	}

	override void OnSpawn(Actor a)
	{
		a.GiveInventory("CCards_Actor_IcyTread", 1);
	}
}

class CCards_Actor_IcyTread : Inventory
{
	bool isdead;
	Vector2 opos;

	override void Tick()
	{
		if(!owner)
		{
			return;
		}

		if(owner.health < 1)
		{
			isdead = true;
		}

		if(owner.health > 0 && isdead)
		{
			opos = OwnerPos2D();
			isdead = false;
		}

		if((level.time % 5) == 0 && !isdead)
		{
			if(opos != OwnerPos2D() && opos != (0,0) && owner.vel.Length() < 20 && owner.vel.z == 0)
			{
				owner.Thrust((opos - OwnerPos2D()).Length() * 0.45, owner.angle + frandom(-10, 10));
				CCards_DropoffHelper.Create(owner, 5);

				if(owner.vel.Length() > 3 && !owner.CheckSightOrRange(128, true) && random(0, 1) == 0)
				{
					owner.A_spawnItemEx("CCards_Actor_SlipFX", random(0, owner.radius), zvel: 0.5, angle:random(0,360));
				}
			}
		}

		opos = OwnerPos2D();
	}

	Vector2 OwnerPos2D()
	{
		return (owner.pos.x, owner.pos.y);
	}
}

class CCards_Actor_SlipFX : CCards_Actor_FX
{	
	Default
	{
		Translation "CCards_IceFloor";
		+BRIGHT;
		scale 0.6;
	}

	States
	{
		Spawn:
		C_F2 MNOPQ 2;
		stop;
	}
}

Class CCard_MonsterForbiddenGaze : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	background = "CARB65";
	canStack = false;
	}
	
	override bool Condition()
	{
		tier++;
		return (monsterFigure.health >= 60);
	}

	override void PreGameStart()
	{
		for(int i; i<players.Size(); i++)
		{
			if(players[i].mo)
			{
				players[i].mo.GiveInventory("CCards_Actor_ForbiddenGaze", 1);
			}
		}
	}

	override void OnSpawn(Actor a)
	{
		a.GiveInventory("CCards_Actor_ForbiddenGazeToken", 1);
	}
}

class CCards_Actor_ForbiddenGazeToken : CCards_Token {}

class CCards_Actor_ForbiddenGaze : Inventory
{
	Default
	{
		inventory.maxamount 1;
	}

	uint burntime;
	Actor burner;

	override void Tick()
	{
		if(!owner || owner.health < 1)
		{
			if(burntime > 0)
			{
				A_StopSound(CHAN_7);
				burntime = 0;
			}
			return;
		}

		if(Level.Time % 5 == 0)
		{
			burner = CheckBurnPlayerLOS();
		}

		if(burner && burner.health > 0)
		{
			burntime++;
		}
		else
		{
			if(burntime > 0)
			{
				owner.A_StopSound(CHAN_7);
				burntime = 0;
				return;
			}
		}
		
		if(burntime == 3)
		{
			owner.A_StartSound("corruptioncards/forbiddensight", CHAN_6, CHANF_OVERLAP, 0.8);
		}

		if(burntime == 10)
		{
			SetOrigin(owner.pos, false);
			owner.A_StartSound("corruptioncards/fireeyes", CHAN_7);
		}

		if(burntime > 10)
		{
			SetOrigin(owner.pos, false);
			owner.A_SpawnItemEx("CCards_Actor_ForbiddenGazeFX", failchance:256-(burntime*2));
		}
		
		if(burntime > 30)
		{
			if(Level.Time % 10 == 0)
			{
				CCards_Actor_ForbiddenGazeDeath f = CCards_Actor_ForbiddenGazeDeath(Spawn("CCards_Actor_ForbiddenGazeDeath", burner.pos));
				owner.DamageMobj(f, f, 2 + (burntime / 80), "CCardsEyeFire", DMG_NO_ARMOR|DMG_THRUSTLESS);
			}
		}
	}

	Actor CheckBurnPlayerLOS()
	{
		FLineTraceData d;
		PlayerPawn p = PlayerPawn(owner);

		if(!p)
		{
			return null;
		}

		p.LineTrace(owner.angle, 9000, p.pitch, 0, (p.height/2) + p.AttackZOffset, 0, 0, d);

		if(d.HitActor && d.HitActor.CountInv("CCards_Actor_ForbiddenGazeToken") > 0)
		{
			CCards_Actor_ForbiddenGazeWarningFX fx = CCards_Actor_ForbiddenGazeWarningFX(Spawn("CCards_Actor_ForbiddenGazeWarningFX"));
			if(fx)
			{
				fx.SetOrigin(d.HitLocation, false);
				fx.A_Face(owner);
				fx.SetOrigin(fx.Vec3Angle(d.HitActor.radius * 1.5, fx.angle + 8, 4), false);
			}

			fx = CCards_Actor_ForbiddenGazeWarningFX(Spawn("CCards_Actor_ForbiddenGazeWarningFX"));
			
			if(fx)
			{
				fx.SetOrigin(d.HitLocation, false);
				fx.A_Face(owner);
				fx.SetOrigin(fx.Vec3Angle(d.HitActor.radius * 1.5, fx.angle - 8, 4), false);
			}


			return d.HitActor;
		}

		return null;
	}
}

Class CCards_Actor_ForbiddenGazeDeath : CCards_Actor_FX
{
	Default
	{
		obituary "%o stared at a forbidden monster for too long.";
	}

	States
	{
		Spawn:
		TNT1 A 3;
		stop;
	}
}

Class CCards_Actor_ForbiddenGazeFX : CCards_Actor_SpawnFire
{
	Default
	{
		scale 0.15;
		renderstyle "STYLE_Add";
		//Translation "CCards_Poison";
		+BRIGHT;
		alpha 0.5;
		+MISSILE;
	}

	states
	{
	Spawn:
    C_FX TUVWXYZ 2 Bright;
    C_F0 A 2 Bright;
    Stop;
	}

	int zoff;
	int yoff;

	override void PostBeginPlay()
	{
		yoff = frandom(-14, 14);
		zoff = frandom(25, 37);
	}

	override void Tick()
	{
		if(target)
		{
			Warp(target, 15, yoff, zoff, 0, WARPF_COPYINTERPOLATION );
		}

		super.Tick();
	}
}

Class CCards_Actor_ForbiddenGazeWarningFX : CCards_Actor_FX
{
	Default
	{
		Scale 1.0;
		+BRIGHT;
		//translation "CCards_Anger";
	}

	states
	{
		Spawn:
		C_F2 MNOPQ 2;
		stop;
	}
}


Class CCard_MonsterPromote : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	background = "CARB66";
	canStack = false;
	}

	Array<GenericBuffCard> cards;
	
	override bool Condition()
	{
		tier = Min(tier + 3, 5);

		if(CCards_Functions.HasMapSpecial(monsterFigure.GetClass()))
		{
			return false;
		}

		for(int i; i<game.deck.Size(); i++)
		{
			GenericBuffCard gb = GenericBuffCard(game.deck[i]);
			if(gb)
			{
				if(gb.monsterType == monsterType)
				{
					continue;
				}

				if(cards.Find(gb) == cards.Size())
				{
					cards.push(gb);
				}
			}
		}

		if(cards.Size() < 3)
		{
			return false;
		}

		ThinkerIterator ti = ThinkerIterator.Create("CCards_MonsterThinker");
		CCards_MonsterThinker t;

		while (t = CCards_MonsterThinker(ti.Next()))
		{
			if(t.user)
			{
				if(t.user.health < monsterFigure.health)
				{
					return false;
				}
			}
		}

		return true;
	}

	override void OnSpawn(Actor a)
	{
		if(cards.Size() == 0)
		{
			return;
		}
		for(int i; i<cards.Size(); i++)
		{
			cards[i].Buff(a);
		}
	}
}

Class CCard_ExtraMonsters : GenericCard
{
	override void Init()
	{
	effectWorld = true;
	background = "CARB67";
	canStack = true;
	cardtag = TAG_WORLD;
	}

	int spawncount;

	override bool Condition()
	{
		if(CCards_Functions.HasMapSpecial(monsterType))
		{
			return false;
		}

		if(!HasGenericCard() && monsterfigure.health < 150)
		{
			return false;
		}

		return true;
	}

	bool HasGenericCard()
	{
		for(int i; i<game.global.collection.Size(); i++)
		{
			GenericCard g = GenericCard(game.global.collection[i]);

			if(g && g.monsterType == monsterType)
			{
				return true;
			}
		}

		return false;
	}

	override void OnGameStart(Actor a)
	{
		if(CCards_Functions.HasMapSpecial(monsterType))
		{
			spawncount = 0;
			return;
		}

		spawncount = Level.Total_Monsters * 0.25;
		spawncount = spawncount - (GetDefaultByType(monsterType).health / 50);
		//Console.Printf("" .. spawncount);
		spawncount = Clamp(spawncount, 5, 50);

		if(GetDefaultByType(monsterType).bBOSS)
		{
			spawncount = Min(3, spawncount);
		}
	}
	
	override void OnTick(Actor a)
	{
		if(spawncount > 0 && (Level.Time % 2) == 0)
		{
			CCards_Safespawner.New(monsterType.GetClassName(), spawncount, "CCards_Actor_SpawnFire", GetDefaultByType(monsterType).radius, GetDefaultByType(monsterType).height, 256, 5);
			
			spawncount = 0;
		}
	}
}


Class CCard_VesselMonster : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	background = "CARB68";
	canStack = true;
	}
	
	Class<Actor> spawned;

	override bool Condition()
	{
		if(tier < 5)
		{
			tier = 5;
		}

		if(monsterFigure.health < 400 || 
		CCards_Functions.HasMapSpecial(monsterType) ||
		CCards_Functions.CountMonsterName(monsterType) > CCards_Functions.CountMonsters() * 0.05)
		{
			SetDebugDefaults();
			return false;
		}

		GetSpawnedMonster();

		if(!spawned)
		{
			SetDebugDefaults();
			return false;
		}

		String monstername = GetDefaultByType(spawned).GetTag();
		//tier = calculateTier(GetDefaultByType(users[r].monsterClass).health);
		description = GetMonsterName() .. " spawns 3 " .. monstername .. " on death.";

		return true;
	}

	void SetDebugDefaults()
	{
		spawned = "LostSoul";
		description = GetMonsterName() .. " spawns 3 Lost Souls on death.";
	}

	void GetSpawnedMonster()
	{
		ThinkerIterator ti = ThinkerIterator.Create("CCards_MonsterThinker");
		CCards_MonsterThinker t;

		Array<Class<Actor> > mons;

		while (t = CCards_MonsterThinker(ti.Next()))
		{
			if(t.user)
			{
				if(CCards_Functions.HasMapSpecial(t.user.GetClass()) || t.user.GetClass() == monsterType)
				{
					continue;
				}

				if(t.user.health < monsterFigure.health / 2 && t.user.health > monsterFigure.health / 8)
				{
					mons.Push(t.user.GetClass());
				}
			}
		}
		
		if(mons.Size() > 0)
		{
			spawned = mons[random(0, mons.Size() - 1)];
		}
	}

	override void OnDeath(Actor a)
	{
		if(a.CountInv("CCards_Token_VesselSpawn") > 0)
		{
			return;
		}
		CCards_VesselSpawn v = CCards_VesselSpawn(Actor.Spawn("CCards_VesselSpawn", a.pos));
		v.angle = a.angle;
		v.count = 3;
		v.spawnclass = spawned;
		v.target = a;
	}

}

class CCards_VesselSpawn : Actor
{
	Default
	{
		+NOINTERACTION;
		+NOGRAVITY;
		-SOLID;
	}

	Class<Actor> spawnclass;
	uint count;

	states
	{
		Spawn:
		TNT1 A 5;
		TNT1 A 13
		{
			A_StartSound("corruptioncards/vesselspawn");
			CCards_VesselFX v;
			v = CCards_VesselFX(Spawn("CCards_VesselFX", pos));
			v.target = self;
			if(target)
			{
				v.A_SetScale(v.scale.x + ((target.radius / 10) * 0.16), v.scale.y + ((target.radius / 10) * 0.16));
			}
			v = CCards_VesselFX(Spawn("CCards_VesselFX", pos));
			v.target = self;
			v.A_SetScale(0.9, 0.9);
			if(target)
			{
				v.A_SetScale(v.scale.x + ((target.radius / 10) * 0.16), v.scale.y + ((target.radius / 10) * 0.16));
			}
			v.dir = true;
		} //A_SpawnItemEx("CCards_VesselFX", 0, 0, 32);
		TNT1 A 10
		{
			for(int i; i<count; i++)
			{
				angle += 120;
				Actor a = Spawn(spawnclass, pos + (0,0,8));
				if(!a)
				{
					continue;
				}
				if(target && target.CountInv("CCards_Actor_MiniMonsterPowerup") > 0)
				{
					a.GiveInventory("CCards_Actor_MiniMonsterPowerup", 1);
				}
				a.GiveInventory("CCards_Token_VesselSpawn", 1);
				a.angle = angle;
				a.A_ChangeVelocity(10, 0, 0, CVF_RELATIVE);
				a.GiveInventory("CCards_Actor_SolidHelper", 1);
				if(target.target && target.target.player)
				{
					a.A_Face(target.target);
				}
				
				if(a.CheckBlock(CBF_NOACTORS))
				{
					a.A_DamageSelf(1);
				}

			}
		}
		stop;
	}

	override void Tick()
	{
		if(target)
		{
			Warp(target,0,0,0);
		}
		Super.Tick();
	}
}

class CCards_VesselFX : CCards_Actor_Smoke
{
	Default
	{
		scale 1.3;
		+BRIGHT;
		+MISSILE;
		alpha 1.0;
		Renderstyle "STYLE_Add";
		translation "CCards_Vessel";
	}

	states
	{
	Spawn:
	TNT1 A 0;
	TNT1 A 0
	{
		if(random(0,1) == 0)
		{
			//dir = true;
		}
		roll = random(0, 359.0);
	}
	Goto Fade;
	Fade:
    //C_F1 BBBCCDDDEEEFFFGGGHHH 1
	C_FX IIIJJJKKKLLLMMMMNNNNOOOO 1
	{
		if(target)
		{
			Warp(target,0,0,32);
		}
		A_FadeOut(0.005);
		A_SetScale(scale.x + 0.02, scale.y + 0.02);
		A_ScaleVelocity(0.9);
	}
    stop;
	}

	override void Tick()
	{
		A_SetRoll(dir ? roll + 4.7 : roll - 4.7);
		Super.Tick();
	}
}

class CCards_Token_VesselSpawn : CCards_Token
{}


Class CCard_MonsterFirstStrike : CCard_MonsterLastWord
{
	override void Init()
	{
	Super.Init();
	effectMonsters = true;
	tier = 0;
	background = "CARB69";
	description = "";
	canStack = true;
	usespecies = true;
	}

	override void OnDeath(Actor a)
	{
	}

	override void OnSpawn(Actor a)
	{
		if(!projectile)
		{
			return;
		}

		let l = CCards_Actor_FirstStrikeInv(a.Spawn("CCards_Actor_FirstStrikeInv"));
		l.projectile = projectile;
		l.AttachToOwner(a);
	}

	override bool Condition()
	{	
		if(!projectile)
		{
			FindProjectile();
		}

		if(projectile)
		{
			if(CCards_Functions.CountMonsterName(monsterType) < 5)
			{
				return false;
			}
			return true;
		}
		
		// Defaults for debug viewing
		projectile = "DoomImpBall";
		tier = 1;
		description = GetMonsterName() .. " fire a Imp projectile upon seeing the player.";
		return false;
	}

	override void SetDescription(String name)
	{
		description = GetMonsterName() .. " fire a " .. name .. " projectile upon seeing the player.";
	}
}

Class CCards_Actor_FirstStrikeInv : Inventory
{
	Class<Actor> projectile;
	uint seed;

	override void PostBeginPlay()
	{
		seed = random(0, 1000);
	}

	override void Tick()
	{
		if(owner && owner.target && owner.target.player)
		{
			if((Level.Time + seed) % 10 == 0 && owner.CheckSight(owner.target, SF_IGNOREVISIBILITY))
			{
				let l = CCards_Actor_FirstStrikeShot(owner.Spawn("CCards_Actor_FirstStrikeShot", owner.pos + (0,0,owner.default.height / 2)));

				if(!l)
				{
					return;
				}
				
				l.projectile = projectile;
				l.target = owner;

				if(owner.target)
				{
					l.tracer = owner.target;
				}
				else
				{
					l.tracer = l;
				}
				DetachFromOwner();
				Destroy();
				return;
			}
		}

		Super.Tick();
	}
}

Class CCards_Actor_FirstStrikeFX : CCards_Actor_FX	
{
	Default
	{
		+FLATSPRITE;
		+BRIGHT;
		scale 0.8;
	}
	states
	{
		Spawn:
		C_F3 R 1
		{
			pitch = -90;
			A_ScaleVelocity(0.7);
			if(GetAge() > 10)
			{
				A_FadeOut(0.1);
			}
		}
		loop;
	}
}

Class CCards_Actor_FirstStrikeShot : CCards_Actor_LastWordPortal
{
	Default
	{
		renderstyle "STYLE_Add";
		alpha 0.8;
		scale 1.0;
	}

	states
	{
		Spawn:
		TNT1 A 1;
		TNT1 A 0
		{
			if(!projectile)
			{
				projectile = "DoomImpBall";
			}
			A_FaceTracer();
		}
		TNT1 A 0 
		{
			A_PlaySound("corruptioncards/firststrike", CHAN_VOICE);
			if(target)
			{
				Warp(target, (target.radius / 2), 0, target.default.height /2);
				A_FaceTracer();
				A_SpawnItemEx("CCards_Actor_FirstStrikeFX", 12, 0, 0, 8);
			}
		}
		//TNT1 AAAAA 2;
		TNT1 A 15;
		TNT1 A 10
		{
			//A_StopSound(CHAN_VOICE);
			//A_PlaySound("corruptioncards/shockwave");

			A_FaceTracer();	
			WarpCenter();

			if(tracer && target && target.health > 0)
			{
				let f = FireProjectile();
				if(f)
				{
					f.A_ScaleVelocity(1.025);
				}
			}
			//SpawnProjectile(projectile);
		}
		stop;
	}

	void WarpCenter()
	{
		if(target)
		{
			Warp(target, (target.radius / 2) + (GetDefaultByType(projectile).radius / 2), 0, target.default.height /2);
		}
	}
}

Class CCard_MonsterSOS : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	background = "CARB71";
	canStack = false;
	}

	uint count;

	override void SetTier()
	{
		Super.SetTier();

		tier = Min(tier, 3);
	}
	
	override bool Condition()
	{
		if(monsterFigure.bBOSS || CCards_Functions.HasMapSpecial(MonsterType) || monsterFigure.default.health > 600)
		{
			return false;
		}
		
		return true;
	}

	override void PreGameStart()
	{
		count = 0;
	}

	override void OnSpawn(Actor a)
	{
		//count = 0;
		if(count > 0)
		{
			count--;
			return;
		}

		if(!a.bBOSS)
		{
			a.GiveInventory("CCards_Token_SOS", 1);
			count = random(5, 8);
			return;
		}
	}

	override void OnDeath(Actor a)
	{
		CCards_Token_SOS s = CCards_Token_SOS(a.FindInventory("CCards_Token_SOS"));

		if(s)
		{	
			s.Trigger();
		}
	}
}

Class CCards_Token_SOS : CCards_Token
{
	Actor mon;
	Vector3 newpos;
	uint countdown;

	override void Tick()
	{
		if(owner && countdown == 1)
		{
			if(mon && mon.health > 0)
			{
				mon.SpawnTeleportFog(mon.pos, true, false);
				mon.SetOrigin(newpos, false);
				mon.SpawnTeleportFog(mon.pos, true, false);
				mon.angle = owner.angle;
				if(owner.target && owner.target.player)
				{
					mon.target = owner.target;
					mon.lastheard = owner.target;
				}

				mon.GiveInventory("CCards_Actor_SolidHelper", 1);
			}
		}

		if(countdown>0)
		{
			countdown--;
		}

		Super.Tick();
	}

	void Trigger()
	{
		if(!owner)
		{
			return;
		}
		newpos = owner.pos;
		GetMonster();
		if(mon && countdown == 0)
		{
		owner.A_SpawnItemEx("CCards_Actor_SOSFXSpawner", 0, 0, owner.default.height/2);
		countdown = 20;
		}
	}

	void GetMonster()
	{
			Array<Actor> monsters;

			ThinkerIterator ti = ThinkerIterator.Create("CCards_MonsterThinker");
			CCards_MonsterThinker t;

			int maxhp;

			while (t = CCards_MonsterThinker(ti.Next()))
			{
				if(t.user && 
				t.user != owner &&
				t.user.health > 0 && 
				t.user.Distance2D(owner) < 1500 && 
				t.user.CheckIfSeen() &&
				t.user.tid == 0 &&
				!t.user.bFRIENDLY &&
				!CCards_Functions.HasMapSpecial(t.user.GetClassName())
				)
				{
					if(t.user.default.health > maxhp)
					{
						maxhp = t.user.default.health;
					}
					monsters.Push(t.user);
				}
			}

			if(monsters.Size() == 0)
			{
				return;
			}

			while(monsters.Size() > 0)
			{
				if(mon)
				{
					break;
				}
				int r = random(0, monsters.Size() - 1);
				Actor m = monsters[r];

				if(maxhp < 0)
				{
					//Console.Printf("out of attempts!");
					break;
				}
				
				maxhp = maxhp - (1 + (maxhp * 0.1));

				if(m.default.health <= maxhp)
				{
					continue;
				}

				//Vector3 oldpos = m.pos;
				//m.SetOrigin(owner.pos, false);

				//if(m.Warp(owner, flags:WARPF_TESTONLY))
				if(TestNewSpot(m))
				{
					mon = m;
					//Console.Printf("got " .. mon.GetClassName());
				}
				else
				{
					//Console.Printf("couldnt port " .. m.GetClassName());
					monsters.Delete(r);
				}
				//m.SetOrigin(oldpos, false);
			}
	}

	bool TestNewSpot(Actor a)
	{
		return (!CCards_ActorTools.CheckClippingBox(newpos, a.height, a.radius));
		//return (a.Warp(owner, newpos.x, newpos.y, newpos.z, 0, WARPF_TOFLOOR|WARPF_ABSOLUTEPOSITION|WARPF_TESTONLY));
	}
}

Class CCards_Actor_SOSFXSpawner : CCards_Actor_FX
{
	states
	{
		Spawn:
		TNT1 A 0;
		TNT1 A 0 A_StartSound("corruptioncards/SOS", volume: 0.7, attenuation: 0.7);
		TNT1 AAA 4 A_SpawnItemEx("CCards_Actor_SOSFX");
		stop;
	}
}

Class CCards_Actor_SOSFX : CCards_Actor_FX
{
	Default
	{
		+FORCEXYBILLBOARD;
		+BRIGHT;
		scale 0.5;
	}

	states
	{
		Spawn:
		C_F3 S 1
		{
			A_SetScale(scale.x + 0.2, scale.y + 0.2);
			A_FadeOut(0.10);
		}
		loop;
	}

	Override void PostBeginPlay()
	{
		bXFLIP = random(0, 1);
		bYFLIP = random(0, 1);
	}
}


Class CCard_MonsterBombardment : GenericCard
{
	override void Init()
	{
	Super.Init();
	useSpecies = true;
	effectMonsters = true;
	background = "CARB79";
	canStack = false;
	cardtag = TAG_AUGMENT;
	}
	
	Class<Actor> projectile;

	override void SetTier()
	{
		Super.SetTier();

		tier = min(tier + 1, 5);
	}

	override bool Condition()
	{
		let pmon = game.global.observer.checkProjectileUser(monsterType.GetClassName());

		if(!pmon || pmon.unsafeProjectile)
		{
			projectile = "DoomImpBall";
			return false;
		}

		projectile = pmon.projectile;	
		
		return true;
	}

	override void OnSpawn(Actor a)
	{
		CCards_Actor_ProjectileBombardment ps = CCards_Actor_ProjectileBombardment(Actor.Spawn("CCards_Actor_ProjectileBombardment", a.pos));
		if(ps)
		{
			ps.projectile = projectile;
			ps.AttachToOwner(a);
		}
	}
}

class CCards_Actor_ProjectileBombardment : Inventory
{
	Class<Actor> projectile;
	uint counter;


	override void Tick()
	{
		if(owner && owner.health > 0)
		{
			if(counter == 0)
			{
				counter = random(1, 42);
			}

			counter--;

			if(owner.target && owner.target.player && owner.target.health > 0)
			{
				if(counter == 6)
				{
					owner.A_SpawnItemEx("CCards_Actor_BombardmentFX");
				}

				if(counter <= 1)
				{
					counter = 42;
					FireProjectile();
				}
			}
		}
		Super.Tick();
	}

	void FireProjectile()
	{
		Actor f = Actor(owner.A_SpawnProjectile(projectile, owner.height/2, 0, 0, ptr:AAPTR_TARGET));

		if(f)
		{
			if(!f.default.seesound)
			{	
				f.A_PlaySound("corruptioncards/shockwave");
			}
			CCards_Token_NotProjectileThrower t = CCards_Token_NotProjectileThrower(Spawn("CCards_Token_NotProjectileThrower"));
			t.AttachToOwner(f);
			f.target = owner;
			if(Abs(f.Vel.x) == 0 && Abs(f.Vel.y) == 0)
			{
				let diff = Vec3To(owner.target);
				float anglePitch = -atan2 (diff.Z, diff.XY.Length());
				f.Vel3DFromAngle(10, angle, anglePitch);
				f.A_Face(owner.target);
			}
		}			
	}
}

class CCards_Actor_BombardmentFX : CCards_Actor_FX
{
	Default
	{
		+MISSILE;
		+BRIGHT;
		+FORCEXYBILLBOARD;
		translation "CCards_Bombardment";
		scale 0.25;
		alpha 0.5;
		//alpha 0.0;
	}

	override void Tick()
	{
		if(target)
		{
			Warp(target, target.radius / 2, 0, target.height / 2, flags:WARPF_NOCHECKPOSITION);
		}
		Super.Tick();
	}

	states
	{
		Spawn:
		C_F1 A 2;
		C_F0 ZYWXY 2;
		stop;
	}
}