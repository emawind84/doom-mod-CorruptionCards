// Wildcards only appear if one is found in game, with the exception of Baphomet's Chosen, and are ALWAYS offered to the player if found.

Class CCard_BaphometsChosen : Card
{
	override void Init()
	{
	canStack = false;
	effectWorld = true;
	tier = 5;
	image = "TNT1A0";
	background = "CARD60";
	description = "";
	alwaysoffer = true;
	customFrame = "graphics/selector/cborde.png";
	cardtag = TAG_EVENT;
	//wildcard = true;
	}

	override bool Condition()
	{
		description = Stringtable.Localize("$" .. "CC_HINT_BAPHOMETSCHOSEN1");

		if(game.global.collection.Size() < 7)
		{
			return false;
		}

		if(CCards_Functions.IsDoom1() && Level.levelnum == 28)
		{
			ThinkerIterator ti = ThinkerIterator.Create("SpiderMastermind");
			SpiderMastermind m = SpiderMastermind(ti.Next());

			if(!m)
			{
				return false;
			}

			description = Stringtable.Localize("$" .. "CC_HINT_BAPHOMETSCHOSEN2");

			return true;
		}

		if(Level.Levelnum != 30)
		{
			return false;
		}

		ThinkerIterator ti = ThinkerIterator.Create("BossEye");
		BossEye t = BossEye(ti.Next());

		if(!t)
		{
			return false;
		}
		
		return true;
	}
	
	override void OnGameStart(Actor a)
	{
		if(CCards_Functions.IsDoom1() && Level.levelnum == 28)
		{
			ThinkerIterator ti = ThinkerIterator.Create("SpiderMastermind");
			SpiderMastermind m = SpiderMastermind(ti.Next());

			if(m)
			{
				m.Spawn("BossTarget", m.pos);
				CCards_Boss_RomeroSpawn b = CCards_Boss_RomeroSpawn(m.Spawn("CCards_Boss_RomeroSpawn", m.pos + (0,0,64)));
				b.angle = m.angle;
				b.bAMBUSH = m.bAMBUSH;
				b.spawned = true;
				m.Destroy();
			}

			return;
		}

		ThinkerIterator ti = ThinkerIterator.Create("BossEye");
		
		bool replaced;
		BossEye t;
		CCards_Boss_RomeroSpawn b;

		while (t = BossEye(ti.Next()))
		{
			if(!replaced)
			{
				b = CCards_Boss_RomeroSpawn(t.Spawn("CCards_Boss_RomeroSpawn", t.pos));
				b.angle = t.angle;
				b.bAMBUSH = t.bAMBUSH;
				b.spawned = true;
				replaced = true;
				t.Destroy();
				continue;
			}
			
			b.totals++;
			t.Destroy();
		}
	}
}

Class CCard_SpookyScarySkeleton : Card
{
	override void Init()
	{
	canStack = false;
	effectWorld = true;
	tier = 5;
	image = "TNT1A0";
	background = "CARD63";
	description = "";
	customFrame = "graphics/selector/cbordp.png";
	cardtag = TAG_EVENT;
	wildcard = true;
	}

	override bool Condition()
	{
		if(game.global && game.global.rules && game.global.rules.concealed)
		{
			return false;
		}

		if(InvalidConiditon())
		{
			return false;
		}
		
		return true;
	}

	bool InvalidConiditon()
	{
		return (
		Level.Levelnum == 30 ||
		CCards_Functions.isSpecialMap() ||
		GameInfo.gametype != GAME_Doom || 
		CCards_Functions.IsDoom1()
		);
	}

	uint chance;
	bool first;
	
	override void OnGameStart(Actor a)
	{
		if(InvalidConiditon())
		{
			return;
		}

		if(chance == 0)
		{
			chance = random(5, 12);
		}
		else
		{
			timer = 0;
			chance--;
			return;
		}

		timer = 0;
		if(!first)
		{
			first = true;
			ThinkerIterator ti = ThinkerIterator.Create("Actor");
			
			Actor t;

			while (t = Actor(ti.Next()))
			{
				if(t.bISMONSTER && t.tid == 0)
				{
					t.A_Remove(AAPTR_DEFAULT);
				}
			}

			timer = random(10, 20) * 35;
			S_ChangeMusic("");
		}
		else
		{
			CCards_Functions.CardAlert("\cgYou hear a familiar shrieking in the distance...", "", 0);
			timer = random(30, 400) * 35;
		}
	}


	int timer;

	override void OnTick(Actor a)
	{
		if(timer>0)
		{
			timer--;
		}

		if(timer == 1)
		{
			CCards_Actor_SafeSpawner a = CCards_Safespawner.New("CCards_SpookySkeleton", 1, "", 40, 110, 0, 0);
            a.SetSpawnLocation(CCards_Functions.RandomPlayer());
            if(a)
			{
				a.minradius = 80;
			}
		}
	}
}

Class CCard_NukageFlow : Card
{
	override void Init()
	{
	effectWorld = true;
	tier = 5;
	image = "CARD67";
	background = "";
	cardtag = TAG_WORLD;
	customFrame = "graphics/selector/cbordp.png";
	wildcard = true;
	}

	Vector2 startingpos;
	bool isnew;

	override bool Condition()
	{
		if(CCards_Functions.CountResurrectables() < 5)
		{
			return false;
		}
		return Super.Condition();
	}

	override void OnGameStart(Actor a)
	{
		Actor p = CCards_Functions.RandomPlayer();
	
		if(p)
		{
			startingpos = (p.pos.x, p.pos.y);
		}
		else
		{
			startingpos = (0, 0);
		}

		if(!isnew)
		{
			S_ChangeMusic("MUCUSF");
            level.ChangeSky(Texman.CheckForTexture("CC_MFFS", TexMan.TYPE_ANY), Texman.CheckForTexture("CC_MFFS", TexMan.TYPE_ANY));
			isnew = true;
		}

		radius = 128;
	}

	float radius;

	override void OnTick(Actor a)
	{
		radius += 0.052;

		if(Level.Time % 35 == 0)
		{
			for(int i; i<level.sectors.Size(); i++)
			{
				if((level.sectors[i].CenterSpot - startingpos).Length() < radius)
				{
					level.sectors[i].SetTexture(0, Texman.CheckForTexture("CC_MFF", TexMan.TYPE_ANY), 0);

					for(int l; l<level.sectors[i].Lines.Size(); l++)
					{
						if(level.sectors[i].Lines[l].Sidedef[1] && level.sectors[i].Lines[l].special == 0)
						{
							level.sectors[i].Lines[l].Sidedef[0].SetTexture(Side.Bottom, Texman.CheckForTexture("CC_MF1", TexMan.TYPE_ANY));
							level.sectors[i].Lines[l].Sidedef[1].SetTexture(Side.Bottom, Texman.CheckForTexture("CC_MF1", TexMan.TYPE_ANY));
						}
						
					}
				}
			}
		}

		uint max = 5;

		if(Level.Time % (35*8) == 0)
		{
			ThinkerIterator ti = ThinkerIterator.Create("Actor");
				
			Actor t;
				
			while (t = Actor(ti.Next()))
			{
				if(random(0, 3) == 0 && t.bISMONSTER && t.health < 1 && t.cursector.GetTexture(0) == Texman.CheckForTexture("CC_MFF", TexMan.TYPE_ANY))
				{
					if(!t.CheckIfSeen())
					{
						continue;
					}

					if(t.RaiseActor(t))
					{
						max--;
					}
				}

				if(max == 0)
				{
					return;
				}
			}
		}
	}
}

Class CCard_8BitHero : Card
{
	mixin WorldEvent;

	CCards_Actor_SafeSpawner spawner;
	bool isSpawning;
	bool finished;
	Vector3 pos;

	int power;
	
	override void Init()
	{
	Super.Init();
	effectPlayers = true;
	image = "CARD71";
	background = "";
	canStack = false;
	cardtag = TAG_EVENT;
	tier = 3;
	customFrame = "graphics/selector/cbordp.png";
	wildcard = true;
	}
	
	override bool Condition()
	{	
		return true;
	}
	
	override void OnGameStart(actor a)
	{
		SetEventTotals();
		isSpawning = false;
		finished = false;
		spawner = null;
	}
	
	override void OnTick(actor a)
	{
		if(finished)
		{
			return;
		}

		if(isSpawning)
		{
			ThinkerIterator ti = ThinkerIterator.Create("CCards_AssassinSpawn");
				
			CCards_AssassinSpawn t;
			
			while (t = CCards_AssassinSpawn(ti.Next()))
			{
				if(t.target)
				{
				t.target.target = a;
				t.target.lastheard = a;
				finished = true;
				power++;
				break;
				}
			}

			return;
		}
		
		if(EventTrigger())
		{
			
			spawner = CCards_Safespawner.New("CCards_Actor_Maestro", 1, "CCards_AssassinSpawn", 0, 0, 128, 0);
			if(spawner)
			{
			spawner.SetSpawnLocation(a);
			}
			isSpawning = true;
		}
	}
}


Class CCard_GraceOfLilith : Card
{
	override void Init()
	{
	effectMonsters = true;
	effectProjectiles = true;
	effectWorld = true;
	tier = 5;
	image = "CARD70";
	background = "";
	cardtag = TAG_WORLD;
	customFrame = "graphics/selector/cbordg.png";
	wildcard = true;
	}

	uint power;

	Array<CCards_GlitchEvent> g;

	override bool Condition()
	{
		if(game.global && game.global.rules && game.global.rules.concealed)
		{
			return false;
		}

		return true;
	}

	override void PreGameStart()
	{
		g.Clear();
	}

	override void OnSpawn(Actor a)
	{
		if(a)
		{
			GlitchTrigger(a, 0);
		}
	}

	override void OnDeath(Actor a)
	{
		if(a)
		{
			GlitchTrigger(a, 2);
		}
	}

	override void OnGameStart(Actor a)
	{
		if(a)
		{
			return;
		}
		if(power < 1)
		{
			power = 1;
		}
		power++;
	}

	override void OnTick(Actor a)
	{
		if(a && level.Total_Monsters < 1000)
		{
			GlitchTrigger(a, 1);
		}
	}

	void GlitchTrigger(Actor a, uint type)
	{
		uint triggers;
		for(int i; i<g.Size(); i++)
		{
			if(g[i].actorclass == a.GetClass())
			{
				g[i].Trigger(a, type);
				triggers++;

				if(a.CountInv("CCards_Token_Glitched") == 0)
				{
					a.SetTag(g[i].tag);
					a.GiveInventory("CCards_Token_Glitched", 1);
				}

				if(triggers >= power)
				{
					return;
				}
			}
		}		

		//Console.Printf("added " .. a.GetClassName());
		g.Push(CCards_GlitchEvent.Make(a.GetClass()));
	}
}

Class CCards_Token_Glitched : CCards_Token {}

Class CCards_GlitchEvent play
{
	Class<Actor> actorclass;
	uint glitchevent;
	uint glitchtype;
	uint glitchargs[4];

	const G_SPAWN = 0;
	const G_TICK = 1;
	const G_DEATH = 2;

	const T_THRUST = 0;
	const T_STATS = 1;
	const T_COLOR = 2;
	const T_RENDER = 3;
	const T_FLAGS = 4;
	const T_SECTOR = 5;

	String tag;

	float soundpitch;

	static CCards_GlitchEvent Make(Class<Actor> a)
	{
		CCards_GlitchEvent g = new("CCards_GlitchEvent");
		g.actorclass = a;
		g.glitchevent = random(0, 2);
		g.glitchtype = random(0, 5);
		g.glitchargs[0] = random(1, 256);
		g.glitchargs[1] = random(1, 256);
		g.glitchargs[2] = random(1, 256);
		g.glitchargs[3] = random(1, 256);

		g.tag = GenerateNewTag();

		if(random(0, 1) == 0)
		{
			g.soundpitch = frandom(-0.5, 1.5);
		}
		else
		{
			g.soundpitch = 1.0;
		}

		return g;
	}

	void Trigger(Actor a, uint type)
	{
		if(type == G_TICK && soundpitch != 1.0)
		{
			for(int i; i<8; i++)
			{
				a.A_SoundPitch(i, soundpitch);
			}
		}

		if(type != glitchevent)
		{
			return;
		}

		String f = a.GetClassName();

		if(type == G_TICK && a.GetAge() % (f.Length()*1.5) != 0)
		{
			return;
		}

		switch(glitchtype)
		{
			Case T_THRUST:
				switch(glitchargs[3] % 7)
				{
					Case 0:
					a.A_ChangeVelocity(glitchargs[0] * 0.15, glitchargs[1] * 0.15, a.vel.z, CVF_REPLACE|CVF_RELATIVE);
					break;

					Case 1:
					a.A_ChangeVelocity(glitchargs[0] * 0.15, glitchargs[1] * 0.15, a.vel.z, CVF_REPLACE|CVF_RELATIVE);
					break;

					Case 2:
					a.A_ChangeVelocity(0, 0, glitchargs[0] * 0.15, CVF_RELATIVE);
					break;

					Case 3:
					a.A_ChangeVelocity(0, 0, -(glitchargs[0] * 0.15), CVF_RELATIVE);
					break;

					Case 4:
					a.A_Wander();
					a.A_Wander();
					a.A_Wander();
					break;

					Case 5:
					a.A_Recoil(-(glitchargs[0] * 0.10));
					break;

					Case 6:
					a.A_ScaleVelocity(2.0);
					break;
				}

			break;

			Case T_STATS:
				if(a.bISMONSTER)
				{
					for(int i; i < glitchargs[3] / 75; i++)
					{
						switch(glitchargs[2] % 7)
						{
						Case 0:
						a.speed = glitchargs[0] * 0.085;
						break;

						Case 1:
						if(type == G_TICK)
						{
							break;
						}
						a.health = a.default.health + (glitchargs[0] * 1.5);
						break;

						Case 2:
						a.A_SetSize(a.default.radius + (glitchargs[0] * 0.5), a.default.height * (glitchargs[0] * 0.5), true);
						break;

						Case 3:
						a.MinMissileChance = glitchargs[0] * 0.9;
						break;

						Case 4:
						a.gravity = glitchargs[0] * 0.25;
						break;

						Case 5:
						a.mass = glitchargs[0] * 1.25;
						break;

						Case 6:
						a.A_SetTics(1);
						break;
						}
					}
				}
				else
				{
					for(int i; i < glitchargs[3] / 75; i++)
					{
						switch(glitchargs[2] % 7)
						{
						Case 0:
						a.SetDamage(glitchargs[0] * 0.25);
						break;

						Case 1:
						a.A_SetSize(a.default.radius + (glitchargs[0] * 0.075), a.default.height * (glitchargs[0] * 0.075));
						break;

						Case 2:
						a.bNOGRAVITY = false;
						a.gravity = 1.0;
						break;
						
						Case 5:
						a.poisondamage = glitchargs[0] * 0.055;
						break;

						Case 3:
						a.bBOUNCEONWALLS = true;
						a.bBOUNCEONFLOORS = true;
						a.bBOUNCEONCEILINGS = true;
						a.BounceFactor = glitchargs[0] * 0.055;
						a.bouncecount = 2;	
						break;

						Case 4:
						a.ProjectileKickBack = glitchargs[0] * 0.5;
						break;

						Case 5:
						a.A_SetTics(1);
						break;

						Case 6:
						a.A_SeekerMissile(50, 50, SMF_LOOK|SMF_CURSPEED);
						break;
						}
					}
				}
			break;

			Case T_COLOR:
			let val = 0.5 + (glitchargs[3] * 0.01);
			
			Switch(glitchargs[3] % 5)
			{
				Case 0:
				a.A_SetRenderStyle(val, STYLE_Translucent);
				break;

				Case 1:
				a.A_SetRenderStyle(val, STYLE_Add);
				break;

				Case 2:
				a.A_SetRenderStyle(1.0, STYLE_Shaded);
				a.SetShade("" .. Min(glitchargs[0], 99) .. Min(glitchargs[1], 99) .. Min(glitchargs[2], 99)); 
				break;

				Case 3:
				a.A_SetRenderStyle(val, STYLE_Subtract);
				break;

				Case 4:
				a.A_SetRenderStyle(1.5, STYLE_AddShaded);
				a.SetShade("" .. Min(glitchargs[0], 99) .. Min(glitchargs[1], 99) .. Min(glitchargs[2], 99)); 
				break;
			}
			break;

			Case T_RENDER:
			Switch(glitchargs[3] % 6)
			{
				Case 0:
				a.A_SetScale(glitchargs[0] * 0.01, glitchargs[1] * 0.01);
				break;

				Case 1:
				a.bROLLSPRITE = true;
				a.bROLLCENTER = true;
				a.roll = glitchargs[0] % 360;
				break;

				Case 2:
				a.bWALLSPRITE= true;
				break;

				Case 3:
				a.bSPRITEANGLE = true;
				a.spriteangle = glitchargs[0] * 0.5;
				break;

				Case 4:
				a.bYFLIP = !a.bYFLIP;
				break;

				Case 5:
				a.bXFLIP = !a.bXFLIP;
				break;
			}
			break;

			Case T_FLAGS:			
			Switch(glitchargs[3] % 16)
			{
				Case 0: a.bSOLID = !a.bSOLID; break;
				Case 1: a.bFRIENDLY = !a.bFRIENDLY; break;
				Case 2: a.bQUICKTORETALIATE = !a.bQUICKTORETALIATE; break;
				Case 3: a.bCANTLEAVEFLOORPIC = !a.bCANTLEAVEFLOORPIC; break;
				Case 4: a.bFRIGHTENED = !a.bFRIGHTENED; break;
				Case 5: a.bNORADIUSDMG = !a.bNORADIUSDMG; break;
				Case 6: a.bFRIGHTENED = !a.bFRIGHTENED; break;
				Case 7: a.bFLOATBOB = !a.bFLOATBOB; break;
				Case 8: a.bFULLVOLDEATH = !a.bFULLVOLDEATH; break;
				Case 9: a.bVISIBILITYPULSE = !a.bVISIBILITYPULSE; break;
				Case 10: a.bROCKETTRAIL = !a.bROCKETTRAIL; break;
				Case 11: a.bFLOORHUGGER = !a.bFLOORHUGGER; break;
				Case 12: a.bCEILINGHUGGER = !a.bCEILINGHUGGER; break;
				Case 13: a.bNOGRAVITY = !a.bNOGRAVITY; break;
				Case 14: a.bFLOAT = !a.bFLOAT; break;
				Case 15: a.bCANPASS = !a.bCANPASS; break;
			}
			break;

			Case T_SECTOR:			
			Switch(glitchargs[3] % 4)
			{
				Case 0:
				a.cursector.SetColor("" .. Min(glitchargs[0], 99) .. Min(glitchargs[1], 99) .. Min(glitchargs[2], 99));
				break;

				Case 1:
				a.cursector.ChangeLightLevel(Max(25, glitchargs[0]));
				break;
				
				Case 2:
				a.cursector.gravity = 0.5;
				break;

				Case 3:
				a.cursector.special = 201 + (glitchargs[0] % 25);
				break;
			}
			if(type != G_TICK)
			{
			//let s = level.sectors[random(glitchargs[1] % 2, level.sectors.Size()-1)].GetTexture(0);
			//a.cursector.SetTexture(glitchargs[2] % 2, s);
			}
			break;
		}
	}

	static String GenerateNewTag()
	{
		String s;
		String names[] = {"-----", "it hurts", "whoami", "test", "zdoom", "ERROR", "corrupted", "DELETETHIS", 
		"anotak", "file read:", "lilith", "index entry $", "incorrect", "rebuilding...", "processing", "errors found",
		"cannot continue?", "nonoNO", "data", "endoffile", "404", "invalid card", "fatal", "theend", "test", "null", "FF00",
		"\n", "Debug", "DECORATE", "ACS", "zscript.", "fixed?", "lifefault", "YOUR_ZDOOM_IS_OLD", "MALFORMED", ";;;;;;;;",
		"BUT SOMETHING IS WRONG.", ".wad", ".pk3", "imsorry"};
		String a = "ABCDEFGHIJKLMNOPQRSTUVWXYZ?@$%Â£!()><|//\\##=={}[];;;...__ ";
		uint l = random(0, 32);

		for(int i; i<l; i++)
		{
			String c = "\c";

			c = c .. a.CharAt(random(0, 11));
			c.ToLower();

			if(random(0, 9) == 0)
			{
				String n = names[random(0, names.Size() - 1)];
				
				if(random(0, 3) != 3)
				{
				n = n.Mid(0, random(0, n.length() - 1));
				}

				s = s .. c .. n;
			}
			else
			{
				s = s .. c .. a.CharAt(random(0, a.Length()-1));
			}
		}

		return s;
	}
}

Class CCard_Sharknado : Card
{
	mixin WorldEvent;

	bool isSpawning;
	bool finished;
	
	override void Init()
	{
	Super.Init();
	effectWorld = true;
	image = "CARD77";
	background = "";
	canStack = false;
	cardtag = TAG_WORLD;
	tier = 3;
	customFrame = "graphics/selector/cbordp.png";
	wildcard = true;
	}
	
	override bool Condition()
	{	
		return (CCards_WeatherManager.CheckValidSkySectors());
	}
	
	override void OnGameStart(actor a)
	{
		SetEventTotals();
		finished = false;
	}
	
	override void OnTick(actor a)
	{
		if(finished)
		{
			return;
		}
		
		if(EventTrigger())
		{
			Actor p = CCards_Functions.RandomPlayer();

			if(p)
			{
				int lowestfloor = 9999;

				for(int i; i<level.sectors.Size(); i++)
				{
					if(lowestfloor > level.sectors[i].FloorPlane.d)
					{
						lowestfloor = level.sectors[i].FloorPlane.d;
					}					
				}

				CCards_Actor_Sharknado s = CCards_Actor_Sharknado(Actor.Spawn("CCards_Actor_Sharknado"));
				Vector3 ppos = p.Vec3Angle(3000, random(0, 360), 0, true);
				s.SetOrigin((ppos.x, ppos.y, lowestfloor), false);
			}

			finished = true;
			CCards_Functions.CardAlert("\cyYou hear a raging storm in the distance...", "corruptioncards/weatheralert", 0);
		}
	}
}

Class CCards_Actor_Sharknado : Actor
{
	Array<CCards_Actor_WhirlwindPart> parts;
	CCards_Actor_WhirlwindAnchor anchor;

	bool ending;
	int endingtimer;

	Default
	{
		+NOGRAVITY;
		+NOINTERACTION;
		reactiontime 2450;
	}

	States
	{
		Spawn:
		TNT1 A 0;
		TNT1 A 0
		{	
			A_StartSound("corruptioncards/tornado", CHAN_7, CHANF_LOOP, 1.0, 0.5);
			int layer = -1;
			int amount = 1;
			
			int wheight = 149;

			int biggest;

			for(int i; i<level.sectors.Size(); i++)
			{
				int h = Abs(level.sectors[i].FloorPlane.d - level.sectors[i].CeilingPlane.d);

				if(h > biggest)
				{
					biggest = h;
				}
			}

			amount = Min(biggest / 149, 10);

			for(int i; i<16*amount; i++)
			{
				if(i%8 == 0)
				{
					layer++;
				}

				CCards_Actor_WhirlwindPart p = CCards_Actor_WhirlwindPart(Spawn("CCards_Actor_WhirlwindPart", pos));
				p.angle = angle;
				p.layer = layer;
				float newscale = 1.0 + (layer * 0.1);
				p.A_SetScale(newscale, newscale);
				angle += 45;
				parts.Push(p);
			}

			anchor = CCards_Actor_WhirlwindAnchor(Spawn("CCards_Actor_WhirlwindAnchor", pos));
		}
		Whirl:
		TNT1 A 1
		{
			for(int i; i<parts.Size(); i++)
			{
				parts[i].Warp(self, 304 + (parts[i].layer * 28), 0, parts[i].layer * 149, angle: ((i - (parts[i].layer * 8)) * 45), flags:WARPF_NOCHECKPOSITION);
			}

			anchor.Warp(self, 304, flags:WARPF_NOCHECKPOSITION);
			
			angle += 5.0;

			ThrowActors();
			SpawnSharks(random(1,2));
			Move();
		}
		loop;
		Death:
		TNT1 A 1
		{
			for(int i; i<parts.Size(); i++)
			{
				parts[i].A_Remove(AAPTR_DEFAULT);
			}
		}
		stop;
	}

	int moveangle;

	void Move()
	{
		if(!target)
		{
			target = CCards_Functions.RandomPlayer();
			return;
		}

		A_Stop();

		if(Distance2D(target) < 800)
		{
			if(!ending)
			{
				ending = true;
				SpawnSharks(8);
			}
		}

		if(ending)
		{
			endingtimer++;
		}

		if(endingtimer < 35*10)
		{
			moveangle = AngleTo(target);
			Thrust(4.2 + GetAge() * 0.002, moveangle);
		}
		else
		{
			A_CountDown();
			Thrust(3.8, moveangle);
		}

	}

	void SpawnSharks(int amount)
	{
		if((Level.Time % 35) != 0)
		{
			return;
		}
		
		if(CCards_Functions.IsInsideSector(cursector, pos.x, pos.y))
		{
			for(int i; i<amount; i++)
			{
			Spawn("CCards_Actor_Shark", (pos.x, pos.y, pos.z + random(0, ceilingz)));
			}
		}
	}

	void ThrowActors()
	{
		if((Level.Time % 5) != 0)
		{
			return;
		}

		ThinkerIterator ti = ThinkerIterator.Create("Actor");
					
		Actor t;
		int count;
				
		while (t = Actor(ti.Next()))
		{
			Inventory inv = Inventory(t);

			if((t.bSHOOTABLE || t.bISMONSTER || (inv && !inv.owner) || t.bMISSILE) && !(Actor.GetReplacee(t.GetClass()) is "Key"))
			{
				if(CCards_Functions.HasMapSpecial(t.GetClass()) || t.GetClassName() == "CCards_Actor_WhirlwindNerf")
				{
					continue;
				}

				float dist = t.Distance2D(self);

				if(dist > 600)
				{
					continue;
				}

				dist = abs(dist - 600);
				
				if(t.bISMONSTER && t.bSOLID)
				{
					t.GiveInventory("CCards_Actor_SolidHelper", 1);
					t.angle += 5.0;
				}

				t.Thrust(dist * 0.04, t.AngleTo(anchor));
				if(Abs(t.ceilingz - t.floorz) >= 256)
				{
					t.A_ChangeVelocity(0,0,Max(0, Max(0, (dist * 0.038) - (t.CountInv("CCards_Actor_WhirlwindNerf") * 0.25))), CVF_RELATIVE);
					t.A_Giveinventory("CCards_Actor_WhirlwindNerf", 1);

					if(t.GetClassName() == "CCards_Actor_Shark")
					{
						t.A_Giveinventory("CCards_Actor_WhirlwindNerf", 2);
					}

					if(t.Countinv("CCards_Actor_WhirlwindNerf") >= 80)
					{
						t.A_TakeInventory("CCards_Actor_WhirlwindNerf", 999);
					}
				}
				count++;
			}
		}
	}
}


class CCards_Actor_WhirlwindNerf : Inventory
{
	Default
	{
		inventory.maxamount 80;
	}
}


class CCards_Actor_WhirlwindAnchor : CCards_Actor_FX
{
	states
	{
		Spawn:
		TNT1 A -1;
		loop;
	}
}

class CCards_Actor_WhirlwindPart : Actor
{
	uint layer;

	Default
	{
		+NOINTERACTION;
		+WALLSPRITE;
		renderstyle "STYLE_Translucent";
		alpha 0.8;
	}
	states
	{
		Spawn:
		C_F3 T 1 
		{
			if(floorz > pos.z - 120 && floorz < pos.z + 120)
			{
				bool spawned;
				Actor act;
				[spawned, act] = A_SpawnItemEx("CCards_Actor_Smoke", 4 + (layer * 304), random(-200, 200), 0, 0, -40, 12, failchance:128);

				if(spawned && act)
				{
					act.SetOrigin((pos.x, pos.y, floorz), false);
					act.A_SetScale(0.8, 0.8);
					act.roll = random(0, 360);
				}
			}
		}
		loop;
	}

	override void PostBeginPlay()
	{
		spriteangle = 90;
	}
}

class CCards_Actor_Shark : Actor
{
	Default
	{
		height 28;
		radius 32;
		+SHOOTABLE;
		+ROLLSPRITE;
		+SLIDESONWALLS;
		+ISMONSTER;
		health 30;
		reactiontime 55;
		tag "Tornado Shark";
		Obituary "%o was bitten by a shark.";
		speed 4;
	}

	bool flopdir;

	states
	{
	Spawn:
	SHRK AAAABBBBCCCCDDDD 1 
	{
		if(floorz-pos.z == 0 && waterlevel < 3)
		{
			SetStateLabel("Splash");
		}

		if(target && Distance3D(target) < 50 && (GetAge() % 15) == 0 && GetAge() > 35)
		{
			if(target.DamageMobj(self, self, random(5, 10), "Bite", angle) > 0)
			{
				A_StartSound("corruptioncards/sharkchomp");
			}
		}

		if(waterlevel == 3)
		{
			if(target)
			{
				A_Chase();
			}
			else
			{
				A_Wander();
				A_LookEx(LOF_NOSOUNDCHECK, 0, 500, 0, 360, "Spawn");
			}

			bFLOAT = true;
			bNOGRAVITY = true;
		}
		else
		{
			bFLOAT = false;
			bNOGRAVITY = false;
		}
	}
	loop;

	Splash:
	SHRK A 0
	{
		roll = random(-50, 50);
		if(target)
		{
			A_FaceTarget();
		}
		else
		{
			angle = random(0, 360);
		}
		A_ChangeVelocity(5 + frandom(0, 12), frandom(-8, 8), random(5, 10), CVF_REPLACE|CVF_RELATIVE);
		flopdir = random(0, 1);
		A_CountDown();

		A_StartSound("corruptioncards/sharkhit", slot:CHAN_VOICE);
		A_SoundPitch(CHAN_VOICE, 1.0 + frandom(-0.1, 0.1));
	}
	SHRK AABBCCDD 1;
	SHRK A 0
	{
		if(!target)
		{
			A_LookEx(LOF_NOSOUNDCHECK, 0, 180, 0, 360, "Spawn");
		}
	}
	Goto Spawn;

	Death:
	TNT1 A 35
	{
		A_Stop();
		SpawnGibs(16, 32, true);
		A_StartSound("corruptioncards/sharkdeath");
		A_SpawnITemEX("CCards_Actor_BloodSmoke", 0, 0, 8, 0, 0, 3);
	}
	stop;
	}

	void SpawnGibs(int spawnx, int spawnz, bool bloody)
	{
		for(int i; i<28; i++)
		{
			bool spawned;
			Actor act;
			[spawned, act] = A_SpawnItemEx("CCards_Actor_GibFX", random(0, spawnx), 0, random(8, spawnz), random(2, 8), 0, random(1, 4), random(0, 360));

			if(spawned && act && !bloody)
			{
				act.A_SetTranslation("CCards_Flesh");
			}
		}
	}

	override void Tick()
	{
		if(waterlevel == 3)
		{
			roll = 0;
			Super.Tick();
			return;
		}
		if(flopdir)
		{
			roll += vel.z;
		}
		else
		{
			roll -= vel.z;
		}

		Super.Tick();
	}
}

Class CCard_TheDunkening : Card
{
	override void Init()
	{
	canStack = false;
	effectMonsters = true;
	tier = 4;
	image = "CARD80";
	//background = "CARD63";
	description = "";
	customFrame = "graphics/selector/cbordp.png";
	cardtag = TAG_MONSTER;
	wildcard = true;
	}

	bool snd;

	override void PreGameStart()
	{
		if(!snd)
		{
			S_Sound("corruptioncards/dunkening", CHAN_VOICE | CHAN_UI, 1.0, ATTN_NONE);
			snd = true;
		}
	}

	override void OnSpawn(Actor a)
	{
		let l = CCards_Actor_LeapAbility(a.Spawn("CCards_Actor_LeapAbility", a.pos));
		if(l)
		{
			l.AttachToOwner(a);
			l.leapchance = 20;
		}
	}
}


Class CCard_DuplicateCard : DeckOperationCard
{
	override void Init()
	{
	canStack = false;
	tier = 5;
	image = "CARD83";
	background = "";
	effectworld = true;
	wildcard = true;
	customFrame = "graphics/selector/cbordp.png";
	cardtag = TAG_MISC;
	}

	Card chosencard;

	override void PostGenSetup()
	{
		// For debug mode
		if(!chosencard)
		{
			chosencard = GetStackable();

			SetDescription();
		}
	}

	void SetDescription()
	{
		if(chosencard)
		{
			String classname = chosencard.GetClassName();
			classname.ToUpper();
			classname.Remove(0, 6);
			string c =  Stringtable.Localize("$" .. "CC_CARD_" .. classname);

			GenericCard gc = GenericCard(chosencard);
			if(gc)
			{
				c = c .. " \cj(" .. gc.GetMonsterName() .. "\cj)";
			}
			description = Stringtable.Localize("$" .. "CC_HINT_DUPLICATECARD1");
			description.Replace("#", "\c-'\cj" .. c .. "\c-'");
		}
		else
		{
			description = "Error! No perma card found.";
		}
	}

	override bool PostGenCondition()
	{
		if(game.global.rules.forcedseed > 0)
		{
			return false;
		}

		chosencard = GetStackable();

		if(!chosencard)
		{
			return false;
		}

		SetDescription();

		return true;
	}

	override bool Condition()
	{
		if(!game.permanentChoice)
		{
			return false;
		}

		return true;
	}

	Card GetStackable()
	{
		Array<Card> cards;

		for(int i; i<game.gen.availableCards.Size(); i++)
		{
			if(game.gen.availableCards[i].canStack)
			{
				if(game.gen.availableCards[i] is "DeckOperationCard")
				{
					continue;
				}
				
				for(int a; a<game.global.collection.Size(); a++)
				{
					//Console.Printf(game.global.collection[a].GetClassName() .. " vs " .. game.gen.availableCards[i].GetClassName());
					if(game.global.collection[a].GetClass() == game.gen.availableCards[i].GetClass())
					{
						GenericCard gc = GenericCard(game.gen.availableCards[i]);
						GenericCard ac = GenericCard(game.global.collection[a]);

						if(gc && ac)
						{
							if(gc.monsterType == ac.monsterType)
							{
								//Console.Printf("added!");
								cards.Push(game.gen.availableCards[i]);
							}
						}
						else
						{
							
								//Console.Printf("added!");
							cards.Push(game.gen.availableCards[i]);
						}
					}
				}
			}
		}

		if(cards.Size() > 0)
		{
			return cards[random(0, cards.Size() - 1)];
		}

		return null;
	}

	bool done;

	override void Operation()
	{
		if(!chosencard || done)
		{
			return;
		}

		for(int i; i<4; i++)
		{
			Card c = Card(new (chosencard.GetClassName()));

			c.game = game;
			c.Init();

			GenericCard gc = GenericCard(c);

			if(gc)
			{
				let sc = GenericCard(chosencard);
				if(sc.group)
				{
					gc.group = sc.group;
				}	
				gc.SetMonsterType(sc.monsterFigure);
				//gc.monsterType = sc.monsterType;
				//gc.monsterName = sc.monsterName;
				gc.tier = sc.tier;
				gc.parsedname = gc.GetMonsterName();
				gc.GetValidSprite(gc.monsterFigure);
			}
			
			c.stackIndex = CCards_Functions.GetCardStackIndex(c);
			game.global.collection.Push(c);

			c.Condition();
			game.deck.Push(c);
		}

		done = true;
	}
}

Class CCard_BodySwapCurse : CurseCard
{
	override void Init()
	{
	Super.Init();
	image = "CARD85";
	wildcard = true;
	customFrame = "graphics/selector/cbordp.png";
	curseinv = "CCards_Actor_BodySwapCurse";
	canstack = false;
	tier = 4;
	}

	override bool Condition()
	{
		if(CCards_Functions.IsSpecialMap() && !mapspecialsafe)
		{
			return false;
		}

		ThinkerIterator ti = ThinkerIterator.Create("Actor");
		Actor t;

		while (t = Actor(ti.Next()))
		{
			if(!CCards_Functions.IsLegalMonster(t) || (CCards_Functions.HasMapSpecial(t.GetClass()) && !mapspecialsafe))
			{
				continue;
			}

			if(!game.global.observer.FindProjectileThrower(t.GetClassName()))
			{
				continue;
			}

			return true;
		}

		return false;
	}

	bool disabled;

	override void PreGameStart()
	{
		disabled = false;
	}

	override void OnTick(Actor a)
	{
		if(CCards_Functions.GetGameTime() < 35 || disabled)
		{
			return;
		}

		if(cursecount > 0)
		{
			ThinkerIterator tei = ThinkerIterator.Create("BossEye");
			BossEye eye = BossEye(tei.Next());

			if(eye)
			{
				disabled = true;
				return;
			}

			Array<Actor> monsters;
			Actor t;
			int largesthp;

			ThinkerIterator ti = ThinkerIterator.Create("Actor");

			while (t = Actor(ti.Next()))
			{
				if(!CCards_Functions.IsLegalMonster(t) || (CCards_Functions.HasMapSpecial(t.GetClass()) && !mapspecialsafe))
				{
					continue;
				}

				if(!game.global.observer.FindProjectileThrower(t.GetClassName()))
				{
					continue;
				}

				monsters.Push(t);
				largesthp = Max(largesthp, t.default.health);
			}

			while(monsters.Size()>0)
			{
				int r = random(0, monsters.Size()-1);

				if(!monsters[r] || monsters[r].CountInv(curseinv)>0 || monsters[r].health < 1)
				{
					monsters.Delete(r);
					continue;
				}

				if(monsters[r].health >= largesthp)
				{
					//Console.Printf(monsters[r].GetClassName());
					monsters[r].GiveInventory(curseinv, 1);
					
					cursecount--;
					return;
				}

				largesthp = largesthp - (largesthp/2);
			}
			
			cursecount--;
		}
	}
}


Class CCards_Actor_BodySwapCurseEffect : CCards_Actor_DuplicationCurseEffect
{
	Default
	{
		//scale 2.5;
		alpha 0.9;	
		Translation "CCards_Pursuit";
		Renderstyle "STYLE_Subtract";
		deathsound "";
	}

	states
	{
		Death:
		TNT1 A 0;
		stop;
	}
}


Class CCards_Actor_BodySwapCurse : Inventory
{
	override void AttachToOwner(Actor a)
	{
		Actor fx = a.Spawn("CCards_Actor_BodySwapCurseEffect", a.pos);
		fx.target = a;
		Super.AttachToOwner(a);
	}

	override void OwnerDied()
	{
		if(!owner)
		{
			return;
		}
		owner.A_SetTics(80);
		CCards_Actor_BodySwapCurseStart b = CCards_Actor_BodySwapCurseStart(Spawn("CCards_Actor_BodySwapCurseStart", owner.pos));
		b.cls = owner.GetClass();
		if(owner.target && owner.target.player)
		{
			b.target = owner.target;
		}
		else
		{
			b.target = CCards_Functions.RandomPlayer();
		}
		A_StartSound("corruptioncards/curse", attenuation:ATTN_NONE);
		b.A_StartSound("corruptioncards/bodyswapstart", attenuation:ATTN_NONE);
	}
}

Class CCards_Actor_BodySwapCurseStart : CCards_Actor_FX
{
	Class<Actor> cls;

	Default
	{
		Translation "CCards_Pursuit";
		Renderstyle "STYLE_Subtract";
		Alpha 0.9;
		+ROLLSPRITE;
		+MISSILE;
	}

	States
	{
		Spawn:
		C_FX AABBAABBAABBAABBAABBAABBAABBAABBAABBAABBAABBAABBAAABBAABBA 1
		{
			A_SpawnItemEx("CCards_Actor_BodySwapCurseStartFX", 0,0,0,10, 0, random(-10, 20), random(0,360));
			A_SetScale(scale.x + 0.08, scale.y + 0.08);
			roll += 0.1;
		}
		Transforming:
		C_FX ABABABABABABABABABABABABABABABABABABABABABABAB 2
		{
			if(target)
			{
				CCards_Actor_BodySwapCurseInheritFX fx = CCards_Actor_BodySwapCurseInheritFX(Spawn("CCards_Actor_BodySwapCurseInheritFX", pos));
				fx.tracer = target;
			}
		}
		C_FX ABABABABABA 2;
		C_FX A 0
		{
			if(target && target.health > 0 && target.player)
			{
				if(target.CountInv("CCards_Actor_BodySwap")>0)
				{
					return;
				}

				CCards_Actor_BodySwap bs = CCards_Actor_BodySwap(Spawn("CCards_Actor_BodySwap", pos));
				bs.hostclass = cls;
				bs.AttachToOwner(target);

				for(int i; i< 32; i++)
				{
					target.A_SpawnItemEx("CCards_Actor_BodySwapCurseStartFX", 0,0,0,10, 0, random(-10, 20), random(0,360));
				}
				target.A_StartSound("corruptioncards/pursuit");
				target.A_Quake(7, 35, 0, 128, "");
			}
		}
		Death:
		C_FX AABB 1
		{
			A_FadeOut(0.1);
		}
		loop;
	}
}

Class CCards_Actor_TestBS : Actor
{
	Default
	{
		+MISSILE;
	}

	override void PostBeginPlay()
	{
		CCards_Actor_BodySwap bs = CCards_Actor_BodySwap(Spawn("CCards_Actor_BodySwap", target.pos));
		bs.hostclass = "HellKnight";
		bs.AttachToOwner(target);
	}
}

Class CCards_Actor_BodySwapCurseStartFX : CCards_Actor_FX
{
	Default
	{
		Translation "CCards_Pursuit";
		Renderstyle "STYLE_Subtract";
		Alpha 0.9;
		+ROLLSPRITE;
	}

	states
	{
		Spawn:
		C_FX AABB 1 A_FadeOut(0.05);
		loop;
	}
	
}

Class CCards_Actor_BodySwapCurseInheritFX : CCards_Actor_BodySwapCurseStartFX
{
	Default
	{
		speed 30;
		scale 0.5;
	}

	states
	{
		Spawn:
		C_FX AABB 1
		{
			A_SeekerMissile(90, 90, SMF_PRECISE);

			if(!tracer)
			{
				A_FadeOut(0.1);
				return;
			}

			if(Distance2D(tracer) < 32)
			{
				if(tracer.CountInv("CCards_Actor_BodySwapStarting") == 0)
				{
					tracer.A_GiveInventory("CCards_Actor_BodySwapStarting", 1);
					tracer.A_StartSound("corruptioncards/bodyswaphit", CHANF_NOSTOP);
					tracer.A_StartSound("corruptioncards/vesselspawn");
				}
				tracer.A_ScaleVelocity(0.90);
				SetStateLabel("Death");
				return;
			}
		}
		loop;
		Death:
		C_FX AABB 1
		{
			A_SeekerMissile(90, 90, SMF_PRECISE);
		}
		TNT1 A 0;
		stop;
	}
}

Class CCards_Actor_BodySwapStarting : Powerup
{
	Default
	{
		powerup.duration -5;
	}
}

Class CCards_Actor_BodySwap : Inventory
{
	Class<Weapon> oldpsprite;
	Class<Actor> hostclass;

	Actor host;

	override void AttachToOwner(Actor other)
	{
		if(!hostclass)
		{
			Destroy();
			return;
		}
		host = owner.Spawn(hostclass, other.pos);

		if(!host)
		{
			Destroy();
			return;
		}

		DisableWeapon(other);
		host.A_ChangeCountFlags(0);
		host.bISMONSTER = false;
		host.species = "Player";
		CCards_BodySwapLink l = CCards_BodySwapLink(Spawn("CCards_BodySwapLink", pos));
		l.AttachToOwner(host);
		l.target = other;

		for(int i; i<7; i++)
		{
			other.A_StopSound(i);
		}

		if(host.default.bFLOAT)
		{
			other.GiveInventory("CCards_Actor_BodySwapFlight", 1);
		}

		if(host.default.health < 100)
		{
			other.health = host.default.health;
		}
		
		Super.AttachToOwner(other);
	}

	override void OwnerDied()
	{
		RestoreWeapon();
	}

	override void Tick()
	{
		if(owner)
		{
			//Console.Printf(owner.pos.z .. " vs " ..  owner.cursector.floorplane.d);
			if(owner.pos.z < -owner.cursector.floorplane.d)
			{
				owner.SetOrigin((owner.pos.x, owner.pos.y, owner.floorz), true);
			}
			DisablePhysics();
		}

		
		if(host && owner)
		{
			if(GetAge() == 35*3 && owner.PlayerNumber() == consoleplayer)
			{
				Console.Printf("You have been cursed with the body of a " .. host.GetTag() .. "!");
			}

			Actor hosttarget = Spawn("CCards_Actor_BodySwapTarget", pos);
			if(host && hosttarget)
			{
				hosttarget.tracer = host;
			}

			if(owner.player.cmd.buttons & BT_ATTACK)
			{
				FLineTraceData trace;
				bool done;
				int i = owner.ceilingz;

				owner.LineTrace(owner.angle, 512, owner.pitch, TRF_THRUACTORS|TRF_THRUSPECIES, owner.height-12, data: trace);

				if(trace.HitActor && trace.HitActor.bSHOOTABLE && !trace.HitActor.bNOTAUTOAIMED && 
				trace.HitActor != self && trace.HitActor != host && !trace.HitActor.bFRIENDLY)
				{
					owner.LineTrace(owner.angle, 512, owner.pitch, TRF_THRUACTORS|TRF_THRUSPECIES, owner.height-12, data: trace);
					hosttarget.SetOrigin(trace.HitLocation, false);
					done = true;
					if(owner.Distance3D(trace.HitActor) < 64)
					{
						hosttarget.SetOrigin(owner.pos, false);
					}
				}

				while(i > owner.floorz && !done)
				{
					i -= 8;
				
					owner.LineTrace(owner.angle, 3000, 0, TRF_THRUACTORS|TRF_THRUSPECIES, 0 + i, data: trace);

					if(trace.HitActor && trace.HitActor.bSHOOTABLE && !trace.HitActor.bNOTAUTOAIMED && 
					trace.HitActor != self && trace.HitActor != host && !trace.HitActor.bFRIENDLY)
					{
						done = true;
						hosttarget.SetOrigin(trace.HitLocation - (0,0,trace.HitActor.height/2), false);
						//Console.Printf(trace.HitActor.GetClassName() .. "");
						break;
					}
				}

				i = -90;

				while(!done && i < 90)
				{
					owner.LineTrace(owner.angle, 3000, i, TRF_THRUACTORS|TRF_THRUSPECIES, owner.height-12, data: trace);

					if(trace.HitActor && trace.HitActor.bSHOOTABLE && !trace.HitActor.bNOTAUTOAIMED && 
					trace.HitActor != self && trace.HitActor != host && !trace.HitActor.bFRIENDLY)
					{
						done = true;
						hosttarget.SetOrigin(trace.HitLocation - (0,0,trace.HitActor.height/2), false);
						//Console.Printf(trace.HitActor.GetClassName() .. "");
						break;
					}

					i++;
				}

				if(!done)
				{
					owner.LineTrace(owner.angle, 512, owner.pitch, TRF_THRUACTORS|TRF_THRUSPECIES, owner.height-12, data: trace);
					hosttarget.SetOrigin(trace.HitLocation, false);
				}
				//Console.Printf(trace.HitActor.GetClassName() .. "");
				
				
			}
			else if(owner.player.cmd.buttons & BT_ALTATTACK)
			{
				FLineTraceData trace;
				owner.LineTrace(owner.angle, 512, owner.pitch, TRF_THRUACTORS|TRF_THRUSPECIES, owner.height-12, data: trace);
				hosttarget.SetOrigin(trace.HitLocation, false);
			}
			else
			{
				hosttarget.Warp(owner, 999999, flags:WARPF_NOCHECKPOSITION);
			}

			hosttarget.A_Face(owner);
			hosttarget.Warp(hosttarget, 2);

			host.target = hosttarget;
			host.lastheard = hosttarget;
			
			host.Warp(owner, -12, flags:WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE);
			host.bSOLID = false;
			host.bNOGRAVITY = true;
			host.bNOTARGET = true;
			host.speed = 0;
			//host.bFRIENDLY = true;
			host.reactiontime = 0;
			host.bALWAYSFAST = true;	

			if(owner.CountInv("PowerInvulnerable") >0 )
			{
				host.bINVULNERABLE = true;
			}
			else
			{
				host.bINVULNERABLE = false;
			}

			if(host.health < 1 || owner.health < 1) 
			{
				host.A_Die();
				owner.A_Die();
				Destroy();
				return;
			}

			host.health = owner.health;
		}

		if(!host)
		{
			owner.A_Die();
			Destroy();
		}

		Super.Tick();
	}


/* to help older gzdooms
	override void PreTravelled()
	{
		NewMap()
	}
*/
	void NewMap()
	{
		if(owner)
		{
			owner.A_Stop();
		}
		RestorePhysics();
		Destroy();
		return;
	}

	void DisablePhysics()
	{
		//owner.A_ChangeLinkFlags(1);
		owner.bNONSHOOTABLE = true;
		owner.bSOLID = false;
		owner.sprite = 0;
		owner.bNOPAIN = true;
	}

	void RestorePhysics()
	{
		owner.A_TakeInventory("CCards_Actor_BodySwapFlight", 999);
		//owner.A_ChangeLinkFlags(0);
		owner.bNOPAIN = false;
		owner.bNONSHOOTABLE = false;
		owner.bSOLID = true;
	}

	void RestoreWeapon()
	{
		let p = owner.player;
		p.SetPSprite(PSP_Weapon, p.readyweapon.FindState("Ready"));
	}

	void DisableWeapon(Actor other)
	{
		let p = other.player;
		oldpsprite = p.readyweapon.GetClass();
		p.SetPSprite(PSP_Weapon, curstate);
	}
}

Class CCards_Actor_BodySwapFlight : PowerFlight
{
	Default
	{
		powerup.duration -999999;
	}
}

Class CCards_BodySwapLink : Inventory
{
	override void ModifyDamage (int damage, Name damageType, out int newdamage, bool passive, Actor inflictor, Actor source, int flags)
	{
		if(passive && owner && target && damage > 0)
		{
			target.DamageMobj(inflictor, source, damage, damageType, 0);
		}

		if(!passive && damage > 0)
		{
			newdamage = damage * 4;
		}
	}
}

Class CCards_Actor_BodySwapTarget : Actor
{
	Default
	{
		+SHOOTABLE;
		+NOCLIP;
		height 1;
		radius 16;
		scale 0.25;
		//+INVULNERABLE;
		+NOBLOCKMAP;
		+THRUACTORS;
		+NOBLOOD;
		+NOGRAVITY;
		+NORADIUSDMG;
		+NOINTERACTION;
	}

	states
	{
		Spawn:
		TNT1 A 2;
		stop;
	}

	override int TakeSpecialDamage(Actor inflictor, Actor source, int damage, Name damagetype)
	{
		if(source == tracer && damage > 0)
		{
			CCards_Actor_BodySwapMelee m = CCards_Actor_BodySwapMelee(Spawn("CCards_Actor_BodySwapMelee", source.pos));
			m.target = source;
			m.SetDamage(damage/4);
			//Console.Printf("" .. damage);
		}

		return 0;
	}
}

Class CCards_Actor_BodySwapMelee : Actor
{
	Default
	{
		+MISSILE;
		radius 48;
		height 8;
		damage 1;
	}

	States
	{
		Spawn:
		TNT1 A 4;
		stop;
	}
}

Class CCard_HuntedAgain : Card
{
	override void Init()
	{
	canStack = false;
	effectWorld = true;
	tier = 5;
	image = "CARD93";
	background = "";
	description = "";
	customFrame = "graphics/selector/cbordp.png";
	cardtag = TAG_EVENT;
	wildcard = true;
	}

	override bool Condition()
	{
		if(InvalidConiditon())
		{
			return false;
		}
		
		return true;
	}

	bool InvalidConiditon()
	{
		return (
		Level.Total_Monsters < 50 ||
		Level.Levelnum == 30 ||
		CCards_Functions.isSpecialMap() ||
		GameInfo.gametype != GAME_Doom || 
		CCards_Functions.IsDoom1()
		);
	}

	uint chance;
	bool first;
	
	override void OnGameStart(Actor a)
	{
		if(InvalidConiditon())
		{
			return;
		}

		if(chance == 0)
		{
			chance = random(2, 7);
		}
		else
		{
			chance--;
			return;
		}

		ThinkerIterator ti = ThinkerIterator.Create("Actor");
		
		Actor t;

		while (t = Actor(ti.Next()))
		{
			if(t.bISMONSTER && t.tid == 0 && t.GetClassName() != Actor.GetReplacement("Archvile") && t.GetAge() > 2)
			{
				if((random(0, 8) == 0 && !t.bFLOAT) || t.bBOSS && !t.bFLOAT)
				{
					Actor archy = t.Spawn(Actor.GetReplacement("Archvile"), t.pos);
					if(archy)
					{
						archy.angle = t.angle;
						archy.bAMBUSH = t.bAMBUSH;
					}
				}
				t.A_Remove(AAPTR_DEFAULT);
			}
		}
		
		if(!first)
		{
			S_ChangeMusic("CC_HUNTM");
			first = false;
		}
	}
}

Class CCard_SantaBoss : Card
{
	override void Init()
	{
	canStack = false;
	effectWorld = true;
	tier = 2;
	image = "TNT1A0";
	background = "CARD95";
	description = "";
	customFrame = "graphics/selector/cbordp.png";
	cardtag = TAG_WORLD;
	wildcard = true;
	}

	override bool Condition()
	{
		ThinkerIterator ti = ThinkerIterator.Create("CCards_MonsterThinker");
			
		CCards_MonsterThinker mt;
		Array<Class<Actor> > monsters;

		while (mt = CCards_MonsterThinker(ti.Next()))
		{
			Actor t = mt.user;

			if(t && CCards_Functions.IsLegalMonster(t) && t.health > 0 && t.radius < 64 && !t.bBOSS && t.default.health < 700 && 
			!t.bRETARGETAFTERSLAM && !CCards_Functions.HasMapSpecial(t.GetClass()))
			{
				return true;
			}
		}
		
		return false;
	}

	override void OnTick(Actor a)
	{
		if(CCards_Functions.GetGameTime() == 35*6)
		{
			CCards_Safespawner.New("CCards_Actor_SantaSpawner", 1, "", 64, 128, 0, 0);
		}
	}
}

class CCards_Actor_SantaSpawner : CCards_Actor_FX
{
	states
	{
		Spawn:
		TNT1 A 1;
		stop;
	}

	Override void PostBeginPlay()
	{
		ThinkerIterator ti = ThinkerIterator.Create("CCards_MonsterThinker");
			
		CCards_MonsterThinker mt;
		Array<Class<Actor> > monsters;

		while (mt = CCards_MonsterThinker(ti.Next()))
		{
			Actor t = mt.user;

			if(t && CCards_Functions.IsLegalMonster(t) && t.health > 0 && t.radius < 64 && !t.bBOSS && t.default.health < 700 &&
			!t.bRETARGETAFTERSLAM && !CCards_Functions.HasMapSpecial(t.GetClass()))
			{
				if(monsters.Find(t.GetClass()) == monsters.Size())
				{
					monsters.Push(t.GetClass());
				}
			}
		}

		if(monsters.Size() == 0)
		{
			return;
		}
		
		CCards_Actor_Santa santa = CCards_Actor_Santa(Spawn("CCards_Actor_Santa", pos));

		Class<Actor> hostclass = monsters[random(0, monsters.Size() - 1)];
		CCards_Actor_XmasLeader x, y;

		x = CCards_Actor_XmasLeader(Spawn("CCards_Actor_XmasLeader", pos));

		for(int i; i<4; i++)
		{
			y = CCards_Actor_XmasLeader(Spawn("CCards_Actor_XmasLeader", pos));
			y.link = x;

			Actor a = Spawn(hostclass, pos);
			x.host1 = a;
			x.host1.GiveInventory("CCards_Actor_NoMonsterDamage", 1);
			santa.minions.Push(a);
			a = Spawn(hostclass, pos);
			x.host2 = a;
			x.host2.GiveInventory("CCards_Actor_NoMonsterDamage", 1);
			santa.minions.Push(a);
			
			x = y;
		}

		y.rider = santa;
	}
}


class CCards_Actor_Santa : Actor
{
	Default
	{
		height 56;
		radius 16;
		+ISMONSTER;
		-SOLID;
		-SHOOTABLE;
		+INVULNERABLE;
		+NOGRAVITY;
		+DROPOFF;
		+SLIDESONWALLS;
		+LOOKALLAROUND;
		+NOINFIGHTING;
		speed 10;
		health 300;
		painchance 80;
		tag "Santa Claus";
		obituary "%o made it on to Santa's very naughty list.";
	}

	Array<Actor> minions;

	states
	{
		Spawn:
		SANT A 8
		{
			if(!bINVULNERABLE)
			{
				SetStateLabel("Seek");
				return;
			}

			uint count;
			for(int i; i<minions.Size(); i++)
			{
				if(!minions[i] || minions[i].health < 1)
				{
					count++;
				}
			}

			if(count >= 8 || count >= minions.Size() || minions.Size() == 0)
			{
				bINVULNERABLE = false;
				bNOGRAVITY = false;
				bSHOOTABLE = true;
				bSOLID = true;
			}

			if(random(0, 50) == 0)
			{
				A_StartSound("corruptioncards/santaactive");
			}
		}
		loop;
		Seek:
		SANT A 1 A_Look();
		loop;
		See:
		SANT AAABBBCCCDDD 2 
		{
			bINVULNERABLE = false;
			bSHOOTABLE = true;
			A_Chase();
		}
		loop;
		Missile:
		SANT E 4 A_FaceTarget();
		SANT F 4 
		{
			A_CustomBulletAttack(22.5, 0, 8, 2, "CCards_BulletPuff", 0);
			A_StartSound(CCards_IWAD.BulletSound(0), slot:CHAN_7);
			A_FaceTarget();
		}
		SANT E 4 A_FaceTarget();
		Goto See;
		Pain:
		SANT G 2;
		SANT G 4 A_StartSound("corruptioncards/santapain", slot:CHAN_VOICE);
		Goto See;
		Death:
		SANT H 0 A_StartSound("corruptioncards/santadeath", slot:CHAN_VOICE);
		SANT HIJKLM 4;
		SANT N -1;
		stop;
		Raise:
		SANT MLKJIH 4;
		Goto See;
	}

	override void PostBeginPlay()
	{
		CCards_Actor_SantaSleigh s = CCards_Actor_SantaSleigh(Spawn("CCards_Actor_SantaSleigh", pos));
		s.santa = self;
	}
}

class CCards_Actor_SantaSleigh : CCards_Actor_FX
{
	Default
	{
		Scale 0.5;
	}

	CCards_Actor_Santa santa;

	states
	{
		Spawn:
		TNT1 A 0;
		TNT1 A 0
		{
			A_StartSound("corruptioncards/santabells", 0, CHANF_LOOP);
		}
		SANT O -1;
		stop;
		Death:
		SANT OOOOOOOOOOOOOOOOOOO 1 A_SpawnItemEx("CCards_Actor_ProjectileExplosion", random(10, 64), 0, random(10, 64), 0, 0, 0, random(0,360));
		stop; 
	}

	override void Tick()
	{
		if(bCORPSE)
		{
			Super.Tick();
			return;
		}

		if(!santa || !santa.bINVULNERABLE)
		{
			SetStateLabel("Death");
			bCORPSE = true;
			Super.Tick();
			return;
		}

		Warp(santa, 0, 0, -16, flags:WARPF_INTERPOLATE|WARPF_NOCHECKPOSITION);
		Super.Tick();
	}
}

class CCards_Actor_XmasFX : CCards_Actor_FX
{
	Default
	{
		Translation "CCards_Ghost";
		scale 0.5;
	}

	states
	{
		Spawn:
		C_F0 SRQP 12;
		stop;
	}

	override void Tick()
	{
		A_FadeOut(0.01);
		Super.Tick();
	}
}

class CCards_Actor_XmasLeader : Actor
{
	Default
	{
		-SOLID;
		+THRUACTORS;
		+NOGRAVITY;
		+SLIDESONWALLS;
		height 64;
		radius 64;
	}

	Actor host1;
	Actor host2;
	Actor rider;
	Actor link;
	bool dir;

	states
	{
		Spawn:
		TNT1 A 1
		{
			if(!link)
			{
				A_ChangeVelocity(0.5, 0, frandom(-2, 3), CVF_RELATIVE);
				
				if(dir)
				{
					angle += random(4, 6);
				}
				else
				{
					angle -= random(4, 6);
				}

				if(random(0, 20) == 0)
				{
					dir = !dir;
				}
			}
		}
		loop;
	}

	override void Tick()
	{
		if(GetAge() % 8 == 0)
		{
			A_spawnItemEx("CCards_Actor_XmasFX", 0, random(-64, 64), -16, frandom(-2, 2), frandom(-2, 2), -1, 0, 128);
		}

		if(rider)
		{
			rider.Warp(self, 0, 0, 20, flags:WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE);
			if(!rider.bINVULNERABLE)
			{
				rider = null;
				bCORPSE	= true;
				link.bCORPSE = true;
			}
		}

		if(link)
		{	
			Vector3 dest;
			dest = CCards_Functions.Vec3Lerp(pos, link.pos, 0.2);
			SetOrigin(dest, true);
			A_Face(link);
		}

		if(host1)
		{
			if(host1.health > 0)
			{
				host1.Warp(self, 0, (host1.radius * 1.5), flags:WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE);
				host1.A_Stop();
				host1.bFLOAT = true;
				host1.speed = 0;
			}
			else
			{
				host1.speed = host1.default.speed;
				host1.bFLOAT = host1.default.bFLOAT;
				host1 = null;
			}
		}

		if(host2)
		{
			if(host2.health > 0)
			{
				host2.Warp(self, 0, -(host2.radius * 1.5), flags:WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE);
				host2.A_Stop();
				host2.bFLOAT = true;
				host2.speed = 0;
			}
			else
			{
				host2.speed = host2.default.speed;
				host2.bFLOAT = host2.default.bFLOAT;
				host2 = null;
			}
		}

		if(bCORPSE)
		{
			if(link)
			{
				link.bCORPSE = true;
			}
			Destroy();
		}
		Super.Tick();
	}
}

Class CCard_DemandSupply : Card
{
	override void Init()
	{
	Super.Init();
	effectPlayers = true;
	image = "TNT1A0";
	background = "CARD98";
	canStack = false;
	cardtag = TAG_WORLD;
	tier = 4;
	customFrame = "graphics/selector/cbordp.png";
	wildcard = true;
	priority = 5;
	}

	Array<Actor> items;

	override bool Condition()
	{
		if(game.global && game.global.rules && game.global.rules.concealed)
		{
			return false;
		}

		ThinkerIterator ti = ThinkerIterator.Create("Actor");
			
		Actor t;
		int count;

		FindItems();
			
		if(items.Size()>0)
		{
			return true;
		}
		
		return false;
	}
	
	void FindItems()
	{
		items.Clear();
		
		ThinkerIterator ti = ThinkerIterator.Create("Inventory");
			
		Actor t;
		
		while (t = Actor(ti.Next()))
		{	
			if(t is "Inventory")
			{
				if(!Inventory(t).owner && !(Actor.GetReplacee(t.GetClass()) is "Key"))
				{
					items.Push(t);
				}
			}
		}
	}

	override void OnGameStart(Actor a)
	{
		for(int i; i<items.Size(); i++)
		{
			if(items[i])
			{
				Actor.Spawn("CCards_Actor_SSItemSpawnSpot", items[i].pos);
				items[i].SetOrigin((32640.0, 32640.0, 0), false);
				items[i].A_GiveInventory("CCards_Token_SSUnsafeSpot", 1);
			}
		}
	}
	
	override void PreGameStart()
	{
		FindItems();
		dropped = false;
		holdtime = 0;
	}

	Vector2 oldpos;
	uint holdtime;
	bool dropped;

	override void OnTick(Actor a)
	{
		if(dropped)
		{
			return;
		}

		if(items.Size() == 0)
		{
			dropped = true;
			return;
		}

		if(a.player && a.player.cmd.buttons & BT_USE)
		{
			if(oldpos != (a.pos.x, a.pos.y))
			{
				oldpos = (a.pos.x, a.pos.y);
				holdtime = 0;
			}
			else
			{
				holdtime++;
			}

			if(holdtime == 35 * 2)
			{
				Console.Printf("\cf- Hold \c-USE \cffor 5 more seconds to call in supplies. -");
				a.A_StartSound("corruptioncards/supplyuse", CHAN_VOICE);
			}

			if(holdtime == 35 * 7)
			{
				dropped = true;
				Console.Printf("\cf- Supplies incoming! -");
				//S_Sound("corruptioncards/findwildcard", CHAN_7);
				S_Sound("corruptioncards/supplyship", CHAN_7, attenuation:ATTN_NONE);

				SupplyDrop(a);
			}
		}
	}

	void SupplyDrop(Actor a)
	{
		CCards_Actor_SupplyDrop s = CCards_Actor_SupplyDrop(Actor.Spawn("CCards_Actor_SupplyDrop", a.pos));
		s.items.Copy(items);
		s.oldpos = a.pos;
		a.A_SpawnItemEx("CCards_Actor_SupplyDropStartFX",0,0,10);
		a.A_SpawnItemEx("CCards_Actor_SupplyDropFX");
	}
}

Class CCards_Actor_SupplyDropStartFX : CCards_Actor_FX
{
	Default
	{
		scale 0.5;
		+FLATSPRITE;
		+BRIGHT;
		alpha 1.0;
		renderstyle "Style_Add";
	}

	states
	{
		Spawn:
		C_F4 I 1
		{
			A_SetScale(scale.x + 0.5, scale.y + 0.5);
			A_FadeOut(0.09);
		}
		loop;
	}
}

Class CCards_Actor_SupplyDropFX : CCards_Actor_FX
{
	Default
	{
		xscale 2.0;
		yscale 200.0;
		+FORCEYBILLBOARD; 
		alpha 0.8;
		+BRIGHT;
		renderstyle "STYLE_Add";
		translation "CCards_SpecalistGreen";
	}

	states
	{
	Spawn:
	C_F4 Q 120;
	Fade:
	C_F4 Q 1 A_FadeOut(0.01);
	loop;
	}
}

Class CCards_Actor_SupplyDrop : Actor
{
	Default
	{
		-SOLID;
		speed 7;
		radius 5;
		height 40;
		renderstyle "None";
	}

	Array<Actor> items;
	Vector3 oldpos;
	uint itemno;

	states
	{
		Spawn:
		PLAY A 120;
		Spawning:
		PLAY AAA 0 A_Wander;
		PLAY A 0 
		{
			if(random(0, 10) == 0)
			{
			SetStateLabel("SDrop");
			}
		}
		loop;
		SDrop:
		PLAY A 1 
		{
			while(!items[itemno])
			{
				itemno++;
				if(itemno >= items.Size()-1)
				{
					SetStateLabel("Death");
					return;
				}
			}

			items[itemno].SetOrigin(pos, false);
			items[itemno].A_Stop();
			items[itemno].A_SpawnItemEx("CCards_Actor_ItemFog");
			SetOrigin(oldpos, false);
			items[itemno].A_StartSound("misc/spawn");
			angle = random(0, 360);
			itemno++;

			if(itemno >= items.Size()-1)
			{
				SetStateLabel("Death");
				return;
			}
		}
		Goto Spawning;
		Death:
		TNT1 A 100;
		stop;
	}
}


Class CCard_Armageddon : Card
{
	bool disabled;

	override void Init()
	{
	effectMonsters = true;
	tier = 4;
	image = "TNT1A0";
	background = "CARD101";
	canStack = false;
	cardtag = TAG_EVENT;
	wildcard = true;
	customFrame = "graphics/selector/cbordp.png";
	}
	
	bool triggered;
	uint triggercount;
	String triggerinv;

	override bool Condition()
	{
		if(game.global.progress >= 20)
		{
			return false;
		}

		return (Level.Total_Monsters >= 1300 || game.permanentChoice);
	}

	override void PreGameStart()
	{
		triggered = false;
	}

	override void OnGameStart(Actor a)
	{
		if(triggered)
		{
			return;
		}

		triggercount = 1000;
		triggered = true;
		triggerinv = "CCards_Actor_ArmageddonCount";
	}

	override void OnDeath(Actor a)
	{
		if(a.target && a.target.player)
		{
			a.target.A_GiveInventory(triggerinv, 1);

			if(a.target.CountInv(triggerinv)>=triggercount)
			{
				ThinkerIterator ti = ThinkerIterator.Create("Actor");
				Actor t;
				while (t = Actor(ti.Next()))
				{
					if(t.health < 1 || !CCards_Functions.IsLegalMonster(t) || (CCards_Functions.HasMapSpecial(t.GetClass()) && CCards_Functions.IsSpecialMap()))
					{
						continue;
					}

					if(t.CountInv("CCards_Actor_NuclearCurse") == 0)
					{
						t.GiveInventory("CCards_Actor_NuclearCurse", 1);
					}
				}
				a.target.A_TakeInventory(triggerinv, triggercount);
			}
		}
	}
}

class CCards_Actor_ArmageddonCount : CCards_Actor_RevengeCount {}

Class CCard_SwimWithWhales : CCard_SurpriseCyberdemon
{
	override void Init()
	{
	effectWorld = true;
	tier = 5;
	image = "CARD105";
	background = "";
	cardtag = TAG_WORLD;
	wildcard = true;
	customFrame = "graphics/selector/cbordp.png";
	Addtag("addspecialmonster");
	}

	bool FindKeys()
	{
		keys.Clear();
		
		ThinkerIterator ti = ThinkerIterator.Create("Thinker");
				
			Thinker t;
				
			while (t = Thinker(ti.Next()))
			{
				Inventory inv = Inventory(t);
				if(inv)
				{
					if(!inv.owner)
					{
						if(CCards_Functions.ActorIsKey(inv))
						{
							keys.Push(inv);
						}
					}
				}
			}
		
		return (keys.Size()>0);
	}

	override bool Condition()
	{
		if(FindKeys() < 1)
		{
			return false;
		}

		Switch(GameInfo.gametype)
		{
			Case GAME_Doom:
			boss = "Cyberdemon";
			break;

			Case GAME_Heretic:
			boss = "Minotaur";
			break;
		}

		if(!boss)
		{
			return false;
		}

		class<Actor> rep = Actor.GetReplacement(boss);

		if(!rep)
		{
			return false;
		}


		if(rep == boss)
		{
			//description = "Add a " .. GetDefaultByType(rep).GetTag() .. " somewhere in the level.";
			description = Stringtable.Localize("$" .. "CC_HINT_SURPRISECYBERDEMON1");
			description.Replace("#", GetDefaultByType(rep).GetTag());
		}
		else
		{
			description = Stringtable.Localize("$" .. "CC_HINT_SURPRISECYBERDEMON2");
			//description = "Add a Boss Monster somewhere in the level.";
		}

		return !CCards_Functions.HasMapSpecial(rep);
	}

	String keyname;
	uint timer;
	bool trapactive;
	Array<Actor> keys;
	uint trapplayerno;

	override void OnGameStart(Actor a)
	{
		timer = 0;
		FindKeys();
		trapplayerno = 0;

		if(keys.Size() > 0)
		{
			keyname = keys[random(0, keys.Size() - 1)].GetClassName();
			trapactive = true;
		}
	}

	override void OnTick(Actor a)
	{
		if(timer > 0)
		{
			timer--;
			if(timer == 0)
			{
				trapactive = false;
			}

			if(timer == 35 * 7)
			{
				SpawnBoss();
			}

			if(timer == 35 * 4)
			{
				SpawnBoss();
			}

			if(timer == 35 * 1)
			{
				SpawnBoss();
			}
		}

		if(Level.Time % 35 == 0 && trapactive)
		{
			for(int i; i<players.Size(); i++)
			{
				if(players[i].mo && players[i].mo.CountInv(keyname) > 0)
				{
					trapplayerno = i;
					timer = 8*35;
					trapactive = false;
					S_Sound("corruptioncards/whales", CHAN_VOICE, volume:0.55);
					break;
				}
			}
		}
	}

	void SpawnBoss()
	{
		class<Actor> rep = Actor.GetReplacement(boss);

		if(players[trapplayerno].mo)
		{
			if(!CCards_Functions.HasMapSpecial(rep))
			{
				let s = CCards_Safespawner.New(rep.GetClassName(), 1, "TeleportFog", 40, 110, 128, 0);
				if(s)
				{
					s.SetSpawnLocation(players[trapplayerno].mo);
					s.speed = 2;
				}
			}
		}

	}
}